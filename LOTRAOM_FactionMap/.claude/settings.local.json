{
  "permissions": {
    "allow": [
      "Bash(find:*)",
      "Bash(ls:*)",
      "Bash(python:*)",
      "Bash(dir:*)",
      "Bash(powershell:*)",
      "Bash(findstr:*)",
      "Bash(Select-Object -First 1)",
      "Bash(dotnet build:*)",
      "Bash(npm run build:*)",
      "Bash(where npm)",
      "Bash(cmd /c \"where npm\")",
      "Bash(cmd /c \"npm run build\")",
      "Bash(cmd /c \"cd /d C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap && dotnet build 2>&1\")",
      "Bash(cmd /c type \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\\\\regions_meta.json\")",
      "Bash(cmd /c dir \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\\\\highlight_*.png\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\\\\selected_*.png\")",
      "Bash(/tmp/crop_regions.py:*)",
      "Bash(python3:*)",
      "Bash(xargs file:*)",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\analyze_regions.py\" << 'PYEOF'\nimport numpy as np\nfrom PIL import Image\nfrom scipy import ndimage\nimport time\n\n# Load the image\nimg_path = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\image.png\"\nimg = Image.open\\(img_path\\)\nprint\\(f\"Image size: {img.size} \\(width x height\\)\"\\)\nprint\\(f\"Image mode: {img.mode}\"\\)\n\n# Convert to grayscale\ngray = img.convert\\(\"L\"\\)\ngray_arr = np.array\\(gray\\)\nprint\\(f\"Grayscale array shape: {gray_arr.shape}\"\\)\nprint\\(f\"Min pixel: {gray_arr.min\\(\\)}, Max pixel: {gray_arr.max\\(\\)}, Mean: {gray_arr.mean\\(\\):.1f}\"\\)\n\n# Histogram of dark pixels\nprint\\(\"\\\\n--- Dark pixel distribution ---\"\\)\nfor val in [20, 30, 40, 50, 60, 70, 80, 90, 100]:\n    count = np.sum\\(gray_arr < val\\)\n    pct = 100.0 * count / gray_arr.size\n    print\\(f\"  Pixels with gray < {val:3d}: {count:>10,} \\({pct:5.2f}%\\)\"\\)\n\n# Try multiple thresholds\nthresholds = [40, 50, 60, 70, 80]\nmin_region_size = 1000\n\nprint\\(f\"\\\\n{'='*70}\"\\)\nprint\\(f\"Connected component analysis \\(min region size = {min_region_size} pixels\\)\"\\)\nprint\\(f\"{'='*70}\"\\)\n\nbest_threshold = None\nbest_count = 0\nbest_labels = None\n\nfor thresh in thresholds:\n    t0 = time.time\\(\\)\n    \n    # Create border mask: dark pixels are borders\n    border_mask = gray_arr < thresh\n    \n    # Invert: fillable areas are non-border pixels\n    fillable = ~border_mask\n    \n    # Label connected components \\(4-connectivity to respect thin borders\\)\n    # structure for 4-connectivity:\n    struct_4 = np.array\\([[0,1,0],\n                         [1,1,1],\n                         [0,1,0]]\\)\n    \n    labeled, num_features = ndimage.label\\(fillable, structure=struct_4\\)\n    \n    elapsed = time.time\\(\\) - t0\n    \n    # Get region sizes\n    region_sizes = ndimage.sum\\(fillable, labeled, range\\(1, num_features + 1\\)\\)\n    region_sizes = np.array\\(region_sizes\\)\n    \n    # Filter by size\n    large_regions = region_sizes[region_sizes >= min_region_size]\n    large_count = len\\(large_regions\\)\n    \n    # Also count medium and small\n    medium = region_sizes[\\(region_sizes >= 100\\) & \\(region_sizes < min_region_size\\)]\n    small = region_sizes[region_sizes < 100]\n    \n    print\\(f\"\\\\nThreshold: {thresh}\"\\)\n    print\\(f\"  Border pixels: {np.sum\\(border_mask\\):,} \\({100*np.sum\\(border_mask\\)/gray_arr.size:.2f}%\\)\"\\)\n    print\\(f\"  Total connected components: {num_features}\"\\)\n    print\\(f\"  Large regions \\(>={min_region_size}px\\): {large_count}\"\\)\n    print\\(f\"  Medium regions \\(100-999px\\): {len\\(medium\\)}\"\\)\n    print\\(f\"  Small regions \\(<100px\\): {len\\(small\\)}\"\\)\n    \n    if large_count > 0:\n        sorted_sizes = np.sort\\(large_regions\\)[::-1]\n        print\\(f\"  Largest 10 region sizes: {sorted_sizes[:10].astype\\(int\\).tolist\\(\\)}\"\\)\n        if len\\(sorted_sizes\\) > 10:\n            print\\(f\"  ... and {len\\(sorted_sizes\\)-10} more large regions\"\\)\n        print\\(f\"  Total area in large regions: {int\\(large_regions.sum\\(\\)\\):,} px\"\\)\n    \n    print\\(f\"  Time: {elapsed:.2f}s\"\\)\n    \n    # Track best \\(closest to ~30 regions\\)\n    if large_count > best_count or \\(abs\\(large_count - 30\\) < abs\\(best_count - 30\\)\\):\n        best_threshold = thresh\n        best_count = large_count\n        best_labels = labeled\n        best_region_sizes = region_sizes\n\n# Generate visualization for the best threshold\nprint\\(f\"\\\\n{'='*70}\"\\)\nprint\\(f\"Generating visualization for best threshold = {best_threshold} \\({best_count} large regions\\)\"\\)\nprint\\(f\"{'='*70}\"\\)\n\n# Recompute for best threshold to ensure we have correct data\nborder_mask = gray_arr < best_threshold\nfillable = ~border_mask\nstruct_4 = np.array\\([[0,1,0],\n                     [1,1,1],\n                     [0,1,0]]\\)\nlabeled, num_features = ndimage.label\\(fillable, structure=struct_4\\)\nregion_sizes_all = ndimage.sum\\(fillable, labeled, range\\(1, num_features + 1\\)\\)\nregion_sizes_all = np.array\\(region_sizes_all\\)\n\n# Create color visualization\nnp.random.seed\\(42\\)\n# Generate distinct colors for regions\ncolors = np.random.randint\\(50, 255, size=\\(num_features + 1, 3\\), dtype=np.uint8\\)\ncolors[0] = [0, 0, 0]  # background/border = black\n\n# Make small regions dark gray\nfor i in range\\(1, num_features + 1\\):\n    if region_sizes_all[i-1] < min_region_size:\n        colors[i] = [40, 40, 40]\n\n# Map labels to colors\nvis = colors[labeled]\n\n# Overlay border in red for clarity\nvis[border_mask] = [180, 0, 0]\n\n# Save\nout_path = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\regions_debug.png\"\nImage.fromarray\\(vis\\).save\\(out_path\\)\nprint\\(f\"Saved visualization to: {out_path}\"\\)\n\n# Print a summary of all large regions for the best threshold, sorted by size\nlarge_indices = np.where\\(region_sizes_all >= min_region_size\\)[0]\nprint\\(f\"\\\\nAll {len\\(large_indices\\)} large regions \\(threshold={best_threshold}\\):\"\\)\nprint\\(f\"{'Region ID':>10} {'Size \\(px\\)':>12} {'% of image':>10}\"\\)\nsorted_idx = large_indices[np.argsort\\(region_sizes_all[large_indices]\\)[::-1]]\nfor idx in sorted_idx:\n    label_id = idx + 1\n    size = int\\(region_sizes_all[idx]\\)\n    pct = 100.0 * size / gray_arr.size\n    print\\(f\"{label_id:>10} {size:>12,} {pct:>9.2f}%\"\\)\n\nPYEOF)",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\analyze_regions_70.py\" << 'PYEOF'\nimport numpy as np\nfrom PIL import Image\nfrom scipy import ndimage\n\nimg_path = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\image.png\"\nimg = Image.open\\(img_path\\)\ngray = img.convert\\(\"L\"\\)\ngray_arr = np.array\\(gray\\)\n\n# Use threshold 70 - closest to ~30 regions\nthresh = 70\nmin_region_size = 1000\n\nborder_mask = gray_arr < thresh\nfillable = ~border_mask\n\nstruct_4 = np.array\\([[0,1,0],\n                     [1,1,1],\n                     [0,1,0]]\\)\n\nlabeled, num_features = ndimage.label\\(fillable, structure=struct_4\\)\nregion_sizes_all = ndimage.sum\\(fillable, labeled, range\\(1, num_features + 1\\)\\)\nregion_sizes_all = np.array\\(region_sizes_all\\)\n\n# Create color visualization with distinct colors\nnp.random.seed\\(42\\)\ncolors = np.random.randint\\(50, 255, size=\\(num_features + 1, 3\\), dtype=np.uint8\\)\ncolors[0] = [0, 0, 0]\n\nfor i in range\\(1, num_features + 1\\):\n    if region_sizes_all[i-1] < min_region_size:\n        colors[i] = [40, 40, 40]\n\nvis = colors[labeled]\nvis[border_mask] = [180, 0, 0]\n\nout_path = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\regions_debug.png\"\nImage.fromarray\\(vis\\).save\\(out_path\\)\nprint\\(f\"Saved visualization \\(threshold=70, {len\\(region_sizes_all[region_sizes_all >= min_region_size]\\)} large regions\\)\"\\)\n\n# Also generate a version at threshold=60 for comparison\nthresh = 60\nborder_mask = gray_arr < thresh\nfillable = ~border_mask\nlabeled, num_features = ndimage.label\\(fillable, structure=struct_4\\)\nregion_sizes_all = ndimage.sum\\(fillable, labeled, range\\(1, num_features + 1\\)\\)\nregion_sizes_all = np.array\\(region_sizes_all\\)\n\ncolors2 = np.random.randint\\(50, 255, size=\\(num_features + 1, 3\\), dtype=np.uint8\\)\ncolors2[0] = [0, 0, 0]\nfor i in range\\(1, num_features + 1\\):\n    if region_sizes_all[i-1] < min_region_size:\n        colors2[i] = [40, 40, 40]\nvis2 = colors2[labeled]\nvis2[border_mask] = [180, 0, 0]\nout_path2 = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\regions_debug_t60.png\"\nImage.fromarray\\(vis2\\).save\\(out_path2\\)\nprint\\(f\"Saved visualization \\(threshold=60, {len\\(region_sizes_all[region_sizes_all >= min_region_size]\\)} large regions\\)\"\\)\n\n# And threshold 50\nthresh = 50\nborder_mask = gray_arr < thresh\nfillable = ~border_mask\nlabeled, num_features = ndimage.label\\(fillable, structure=struct_4\\)\nregion_sizes_all = ndimage.sum\\(fillable, labeled, range\\(1, num_features + 1\\)\\)\nregion_sizes_all = np.array\\(region_sizes_all\\)\n\ncolors3 = np.random.randint\\(50, 255, size=\\(num_features + 1, 3\\), dtype=np.uint8\\)\ncolors3[0] = [0, 0, 0]\nfor i in range\\(1, num_features + 1\\):\n    if region_sizes_all[i-1] < min_region_size:\n        colors3[i] = [40, 40, 40]\nvis3 = colors3[labeled]\nvis3[border_mask] = [180, 0, 0]\nout_path3 = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\regions_debug_t50.png\"\nImage.fromarray\\(vis3\\).save\\(out_path3\\)\nprint\\(f\"Saved visualization \\(threshold=50, {len\\(region_sizes_all[region_sizes_all >= min_region_size]\\)} large regions\\)\"\\)\n\nprint\\(\"\\\\nDone. Compare the three visualizations to pick the best threshold.\"\\)\nPYEOF)",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\extract_regions_improved.py\" << 'PYEOF'\nimport numpy as np\nfrom PIL import Image\nfrom scipy import ndimage\nimport time\n\nstart = time.time\\(\\)\n\n# === Configuration ===\nSRC_PATH = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\image.png\"\nHITMAP_PATH = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\\\\map_hitmap_new.png\"\nDEBUG_PATH = r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\regions_debug_improved.png\"\nTARGET_W, TARGET_H = 2048, 1423\nBORDER_THRESHOLD = 50\nSMALL_REGION_THRESHOLD = 2000\nHOLE_THRESHOLD = 5000\n\n# === Step 1: Load and convert to grayscale ===\nprint\\(\"Loading image...\"\\)\nimg = Image.open\\(SRC_PATH\\)\nsrc_w, src_h = img.size\nprint\\(f\"  Source size: {src_w}x{src_h}\"\\)\ngray = np.array\\(img.convert\\(\"L\"\\)\\)\n\n# === Step 2: Create border mask \\(dark pixels = borders\\) ===\nprint\\(f\"Creating border mask \\(threshold={BORDER_THRESHOLD}\\)...\"\\)\nborder_mask = gray < BORDER_THRESHOLD  # True = border pixel\nprint\\(f\"  Border pixels: {int\\(np.sum\\(border_mask\\)\\)}\"\\)\n\n# === Step 3: Morphological closing \\(dilate then erode\\) to close gaps ===\nprint\\(\"Applying morphological closing with 5x5 kernel...\"\\)\nstruct_5 = np.ones\\(\\(5, 5\\), dtype=bool\\)\nborder_closed = ndimage.binary_dilation\\(border_mask, structure=struct_5, iterations=1\\)\nborder_closed = ndimage.binary_erosion\\(border_closed, structure=struct_5, iterations=1\\)\n\n# Additional dilation to thicken borders and ensure connectivity\nprint\\(\"Applying additional dilation with 3x3 kernel...\"\\)\nstruct_3 = np.ones\\(\\(3, 3\\), dtype=bool\\)\nborder_thick = ndimage.binary_dilation\\(border_closed, structure=struct_3, iterations=1\\)\nprint\\(f\"  Thickened border pixels: {int\\(np.sum\\(border_thick\\)\\)}\"\\)\n\n# === Step 4: Label connected non-border components ===\nprint\\(\"Labeling connected components...\"\\)\nnon_border = ~border_thick\nlabels, num_features = ndimage.label\\(non_border\\)\nprint\\(f\"  Initial connected components: {num_features}\"\\)\n\n# === Step 5: Compute region sizes ===\nprint\\(\"Computing region sizes...\"\\)\nregion_sizes = ndimage.sum\\(np.ones_like\\(labels\\), labels, range\\(1, num_features + 1\\)\\)\nregion_sizes = np.array\\(region_sizes\\)\n\n# Identify the ocean/background as the largest region\nocean_label = np.argmax\\(region_sizes\\) + 1\nocean_size = region_sizes[ocean_label - 1]\nprint\\(f\"  Ocean/background: label={ocean_label}, size={int\\(ocean_size\\)} pixels\"\\)\n\n# === Step 6: Identify large and small regions ===\nlarge_labels = set\\(\\)\nsmall_labels = set\\(\\)\nfor i in range\\(1, num_features + 1\\):\n    if i == ocean_label:\n        continue\n    if region_sizes[i - 1] >= SMALL_REGION_THRESHOLD:\n        large_labels.add\\(i\\)\n    else:\n        small_labels.add\\(i\\)\n\nprint\\(f\"  Large regions \\(>={SMALL_REGION_THRESHOLD}px\\): {len\\(large_labels\\)}\"\\)\nprint\\(f\"  Small fragments \\(<{SMALL_REGION_THRESHOLD}px\\): {len\\(small_labels\\)}\"\\)\n\n# === Step 7: Merge small fragments into nearest large neighbor ===\nprint\\(\"Merging small fragments into nearest large neighbors...\"\\)\n\n# Build a \"nearest large region\" map using distance transforms\n# For each large region + ocean, compute distance transform and find nearest\nprint\\(\"  Computing nearest-region map via distance transforms...\"\\)\n\n# Create seed: known region pixels\nseed = np.zeros_like\\(labels, dtype=np.int32\\)\nfor ll in large_labels:\n    seed[labels == ll] = ll\nseed[labels == ocean_label] = ocean_label\n\n# Use iterative dilation approach - more memory efficient than per-region distance transforms\nnearest = seed.copy\\(\\)\nunfilled = \\(nearest == 0\\)\nunfilled_count = int\\(np.sum\\(unfilled\\)\\)\nprint\\(f\"  Pixels to fill: {unfilled_count}\"\\)\n\niteration = 0\nwhile unfilled_count > 0:\n    iteration += 1\n    # Dilate the nearest map: for each unfilled pixel, take value from any filled neighbor\n    # We do this by dilating each present label\n    new_nearest = nearest.copy\\(\\)\n    \n    # Get all current labels in the map \\(excluding 0\\)\n    present_labels = np.unique\\(nearest\\)\n    present_labels = present_labels[present_labels > 0]\n    \n    for ll in present_labels:\n        region_mask = \\(nearest == ll\\)\n        dilated = ndimage.binary_dilation\\(region_mask, structure=struct_3, iterations=1\\)\n        assign = dilated & unfilled\n        new_nearest[assign] = ll\n    \n    nearest = new_nearest\n    new_unfilled = \\(nearest == 0\\)\n    new_unfilled_count = int\\(np.sum\\(new_unfilled\\)\\)\n    \n    if new_unfilled_count == unfilled_count:\n        print\\(f\"  Stopped at iteration {iteration}, {unfilled_count} pixels remain unfilled\"\\)\n        break\n    unfilled = new_unfilled\n    unfilled_count = new_unfilled_count\n    if iteration % 10 == 0:\n        print\\(f\"    Iteration {iteration}: {unfilled_count} pixels still unfilled\"\\)\n    if iteration > 300:\n        print\\(f\"  Reached max iterations, {unfilled_count} pixels remain\"\\)\n        break\n\nprint\\(f\"  Dilation completed in {iteration} iterations\"\\)\n\n# Reassign small regions based on majority vote from nearest map\nmerged_labels = labels.copy\\(\\)\nfor sl in small_labels:\n    mask = \\(labels == sl\\)\n    neighbor_labels = nearest[mask]\n    neighbor_labels = neighbor_labels[neighbor_labels > 0]\n    if len\\(neighbor_labels\\) > 0:\n        vals, counts = np.unique\\(neighbor_labels, return_counts=True\\)\n        best = vals[np.argmax\\(counts\\)]\n        merged_labels[mask] = best\n\n# Assign border pixels to nearest region\nborder_pixels = \\(labels == 0\\)\nmerged_labels[border_pixels] = nearest[border_pixels]\n\n# === Step 8: Fill holes inside large regions ===\nprint\\(\"Filling holes inside large regions...\"\\)\nunique_merged = np.unique\\(merged_labels\\)\nunique_merged = unique_merged[\\(unique_merged != ocean_label\\) & \\(unique_merged != 0\\)]\n\ntotal_holes_filled = 0\nfor region_id in unique_merged:\n    region_mask = \\(merged_labels == region_id\\)\n    filled = ndimage.binary_fill_holes\\(region_mask\\)\n    holes = filled & ~region_mask\n    hole_pixels = int\\(np.sum\\(holes\\)\\)\n    if hole_pixels > 0 and hole_pixels < HOLE_THRESHOLD:\n        merged_labels[holes] = region_id\n        total_holes_filled += hole_pixels\n        print\\(f\"  Filled {hole_pixels} hole pixels in region {region_id}\"\\)\n\nprint\\(f\"  Total hole pixels filled: {total_holes_filled}\"\\)\n\n# === Step 9: Renumber regions sequentially ===\nprint\\(\"Renumbering regions...\"\\)\nunique_labels = np.unique\\(merged_labels\\)\n\nremap = {}\nremap[ocean_label] = 0\nremap[0] = 0\n\nnext_id = 1\nfor ul in sorted\\(unique_labels\\):\n    if ul in remap:\n        continue\n    remap[ul] = next_id\n    next_id += 1\n\nfinal = np.zeros_like\\(merged_labels, dtype=np.uint8\\)\nfor old_id, new_id in remap.items\\(\\):\n    final[merged_labels == old_id] = new_id\n\nnum_land_regions = next_id - 1\nprint\\(f\"\\\\n{'='*50}\"\\)\nprint\\(f\"  Found {num_land_regions} land regions \\(excluding ocean\\)\"\\)\nprint\\(f\"{'='*50}\\\\n\"\\)\n\n# Print region sizes\nfor rid in range\\(0, next_id\\):\n    size = int\\(np.sum\\(final == rid\\)\\)\n    label = \"OCEAN\" if rid == 0 else f\"Region {rid}\"\n    pct = 100.0 * size / \\(src_w * src_h\\)\n    print\\(f\"  {label}: {size:>8} pixels \\({pct:.1f}%\\)\"\\)\n\n# === Step 10: Scale to target resolution ===\nprint\\(f\"\\\\nScaling from {src_w}x{src_h} to {TARGET_W}x{TARGET_H} \\(NEAREST\\)...\"\\)\nfinal_img = Image.fromarray\\(final, mode=\"L\"\\)\nhitmap_scaled = final_img.resize\\(\\(TARGET_W, TARGET_H\\), Image.NEAREST\\)\n\n# Save hitmap - region ID in red channel\nprint\\(f\"Saving hitmap to: {HITMAP_PATH}\"\\)\nhitmap_array = np.array\\(hitmap_scaled\\)\nhitmap_rgb = np.zeros\\(\\(TARGET_H, TARGET_W, 3\\), dtype=np.uint8\\)\nhitmap_rgb[:, :, 0] = hitmap_array  # Red channel = region ID\nhitmap_out = Image.fromarray\\(hitmap_rgb, mode=\"RGB\"\\)\nhitmap_out.save\\(HITMAP_PATH\\)\nprint\\(f\"  Hitmap saved: unique region IDs = {sorted\\(np.unique\\(hitmap_array\\).tolist\\(\\)\\)}\"\\)\n\n# === Step 11: Create debug visualization ===\nprint\\(f\"Saving debug visualization to: {DEBUG_PATH}\"\\)\n\n# Generate distinct colors using golden ratio\nnp.random.seed\\(42\\)\ncolors = np.zeros\\(\\(256, 3\\), dtype=np.uint8\\)\ncolors[0] = [30, 60, 120]  # Ocean = dark blue\n\nfor i in range\\(1, next_id\\):\n    hue = \\(i * 0.618033988749895\\) % 1.0\n    h = hue * 6\n    c = 200\n    x = int\\(c * \\(1 - abs\\(h % 2 - 1\\)\\)\\)\n    c = int\\(c\\)\n    if h < 1:\n        r, g, b = c, x, 0\n    elif h < 2:\n        r, g, b = x, c, 0\n    elif h < 3:\n        r, g, b = 0, c, x\n    elif h < 4:\n        r, g, b = 0, x, c\n    elif h < 5:\n        r, g, b = x, 0, c\n    else:\n        r, g, b = c, 0, x\n    colors[i] = [min\\(r + 55, 255\\), min\\(g + 55, 255\\), min\\(b + 55, 255\\)]\n\ndebug_rgb = colors[final]\n\n# Overlay original borders as thin black lines for reference\ndebug_rgb[border_mask] = [0, 0, 0]\n\ndebug_img = Image.fromarray\\(debug_rgb, mode=\"RGB\"\\)\ndebug_img.save\\(DEBUG_PATH\\)\n\nelapsed = time.time\\(\\) - start\nprint\\(f\"\\\\nDone in {elapsed:.1f} seconds.\"\\)\nPYEOF)",
      "Bash(printf 'aW1wb3J0IG51bXB5IGFzIG5wCmZyb20gUElMIGltcG9ydCBJbWFnZQpmcm9tIHNjaXB5IGltcG9ydCBuZGltYWdlCmltcG9ydCB0aW1lCgpzdGFydCA9IHRpbWUudGltZSgpCgpTUkNfUEFUSCA9ICdDOi9Xb3JrL1NvdXJjZXMvZ2l0aHViL0xPVFJBT01fRmFjdGlvbk1hcC9pbWFnZS5wbmcnCkhJVE1BUF9QQVRIID0gJ0M6L1dvcmsvU291cmNlcy9naXRodWIvTE9UUkFPTV9GYWN0aW9uTWFwL0dVSS9TcHJpdGVEYXRhL0ZhY3Rpb25NYXAvbWFwX2hpdG1hcF9uZXcucG5nJwpERUJVR19QQVRIID0gJ0M6L1dvcmsvU291cmNlcy9naXRodWIvTE9UUkFPTV9GYWN0aW9uTWFwL3JlZ2lvbnNfZGVidWdfaW1wcm92ZWQucG5nJwpUQVJHRVRfVywgVEFSR0VUX0ggPSAyMDQ4LCAxNDIzCkJPUkRFUl9USFJFU0hPTEQgPSA1MApTTUFMTF9SRUdJT05fVEhSRVNIT0xEID0gMjAwMApIT0xFX1RIUkVTSE9MRCA9IDUwMDAK')",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\fix_and_generate.py\" << 'PYEOF'\nimport numpy as np\nfrom PIL import Image\nfrom scipy.ndimage import distance_transform_edt, gaussian_filter, label, binary_dilation\nimport json\nimport os\nimport glob\n\nbase_dir = r'C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap'\nMAP_W, MAP_H = 2048, 1423\n\n# =====================================================================\n# Step 1: Fix hitmap - fill all border gaps between regions\n# =====================================================================\nprint\\(\"=== Step 1: Fixing hitmap gaps ===\"\\)\nhitmap = np.array\\(Image.open\\(os.path.join\\(base_dir, \"map_hitmap_new.png\"\\)\\)\\)[:,:,0]\n\noriginal_ocean = \\(hitmap == 0\\).sum\\(\\)\nprint\\(f\"Original ocean pixels: {original_ocean} \\({original_ocean/hitmap.size*100:.1f}%\\)\"\\)\n\n# Label connected components of zero pixels.\n# The largest is ocean. All smaller ones are internal gaps.\nzero_mask = \\(hitmap == 0\\)\nlabels, num_labels = label\\(zero_mask\\)\nprint\\(f\"Zero-pixel connected components: {num_labels}\"\\)\n\n# Find sizes of each component\ncomponent_sizes = {}\nfor lbl in range\\(1, num_labels + 1\\):\n    component_sizes[lbl] = \\(labels == lbl\\).sum\\(\\)\n\n# Largest is ocean\nsorted_components = sorted\\(component_sizes.items\\(\\), key=lambda x: -x[1]\\)\nocean_label = sorted_components[0][0]\nocean_size = sorted_components[0][1]\nprint\\(f\"Ocean component: label={ocean_label}, size={ocean_size} \\({ocean_size/hitmap.size*100:.1f}%\\)\"\\)\n\n# All other zero components are gaps\ngap_mask = zero_mask & \\(labels != ocean_label\\)\ngap_count = gap_mask.sum\\(\\)\nprint\\(f\"Gap pixels to fill: {gap_count}\"\\)\n\n# Show top 10 gap component sizes\nfor lbl, size in sorted_components[1:11]:\n    print\\(f\"  Component {lbl}: {size} pixels\"\\)\n\n# Fill gaps using nearest non-zero pixel\nif gap_count > 0:\n    land_mask = \\(hitmap > 0\\)\n    dist, indices = distance_transform_edt\\(~land_mask, return_indices=True\\)\n    gy, gx = np.where\\(gap_mask\\)\n    hitmap[gy, gx] = hitmap[indices[0][gy, gx], indices[1][gy, gx]]\n    print\\(f\"Filled {len\\(gy\\)} gap pixels\"\\)\n\n# Verify\nnew_ocean = \\(hitmap == 0\\).sum\\(\\)\nprint\\(f\"Ocean after fix: {new_ocean} \\({new_ocean/hitmap.size*100:.1f}%\\)\"\\)\nprint\\(f\"Pixels removed from ocean: {original_ocean - new_ocean}\"\\)\n\n# Save fixed hitmap\nout_hm = np.zeros\\(\\(MAP_H, MAP_W, 3\\), dtype=np.uint8\\)\nout_hm[:,:,0] = hitmap\nImage.fromarray\\(out_hm\\).save\\(os.path.join\\(base_dir, \"map_hitmap_new.png\"\\)\\)\nprint\\(\"Hitmap saved\"\\)\n\n# =====================================================================\n# Step 2: Create proper ocean background  \n# =====================================================================\nprint\\(\"\\\\n=== Step 2: Creating ocean background ===\"\\)\nlandscape = np.array\\(Image.open\\(r\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\image.png\"\\).convert\\(\"RGB\"\\).resize\\(\\(MAP_W, MAP_H\\), Image.Resampling.LANCZOS\\)\\)\n\nocean_mask = \\(hitmap == 0\\)\nbase_map = np.zeros\\(\\(MAP_H, MAP_W, 3\\), dtype=np.uint8\\)\n\n# Ocean: blend landscape with blue tint\nocean_blue = np.array\\([25, 50, 90], dtype=float\\)\nfor c in range\\(3\\):\n    base_map[:,:,c][ocean_mask] = np.clip\\(\n        landscape[:,:,c][ocean_mask].astype\\(float\\) * 0.5 + ocean_blue[c] * 0.5, \n        0, 255\n    \\).astype\\(np.uint8\\)\n\n# Land: dark version of landscape \\(40% brightness\\)\nland_mask_final = ~ocean_mask\nfor c in range\\(3\\):\n    base_map[:,:,c][land_mask_final] = np.clip\\(\n        landscape[:,:,c][land_mask_final].astype\\(float\\) * 0.4,\n        0, 255\n    \\).astype\\(np.uint8\\)\n\nImage.fromarray\\(base_map\\).save\\(os.path.join\\(base_dir, \"map_base.png\"\\)\\)\nocean_brightness = base_map[ocean_mask].mean\\(\\) if ocean_mask.any\\(\\) else 0\nland_brightness = base_map[land_mask_final].mean\\(\\) if land_mask_final.any\\(\\) else 0\nprint\\(f\"map_base.png saved\"\\)\nprint\\(f\"  Ocean mean brightness: {ocean_brightness:.1f}\"\\)\nprint\\(f\"  Land mean brightness: {land_brightness:.1f}\"\\)\n\n# =====================================================================\n# Step 3: Regenerate puzzle pieces with fixed hitmap\n# =====================================================================\nprint\\(\"\\\\n=== Step 3: Regenerating puzzle pieces ===\"\\)\n\n# Delete old highlight files\nold_files = glob.glob\\(os.path.join\\(base_dir, \"highlight_*.png\"\\)\\)\nfor f in old_files:\n    os.remove\\(f\\)\nprint\\(f\"Deleted {len\\(old_files\\)} old highlight files\"\\)\n\nmetadata = {}\ntotal_size = 0\n\nregion_ids = sorted\\([int\\(x\\) for x in np.unique\\(hitmap\\) if x > 0]\\)\nprint\\(f\"Generating {len\\(region_ids\\)} puzzle pieces...\"\\)\n\nfor rid in region_ids:\n    region_name = f\"Region_{rid}\"\n    \n    # Create mask with smooth anti-aliased edges\n    mask = \\(hitmap == rid\\).astype\\(np.float32\\)\n    mask_smooth = gaussian_filter\\(mask, sigma=1.5\\)\n    alpha = np.clip\\(mask_smooth * 3.0, 0, 1\\)\n    alpha = \\(alpha * 255\\).astype\\(np.uint8\\)\n    \n    # Find bbox\n    rows = np.any\\(alpha > 0, axis=1\\)\n    cols = np.any\\(alpha > 0, axis=0\\)\n    if not rows.any\\(\\) or not cols.any\\(\\):\n        continue\n    rmin, rmax = np.where\\(rows\\)[0][[0, -1]]\n    cmin, cmax = np.where\\(cols\\)[0][[0, -1]]\n    \n    # 2px padding\n    rmin = max\\(0, rmin - 2\\)\n    rmax = min\\(MAP_H - 1, rmax + 2\\)\n    cmin = max\\(0, cmin - 2\\)\n    cmax = min\\(MAP_W - 1, cmax + 2\\)\n    \n    bbox_w = cmax - cmin + 1\n    bbox_h = rmax - rmin + 1\n    \n    # Crop\n    crop_rgb = landscape[rmin:rmax+1, cmin:cmax+1, :]\n    crop_alpha = alpha[rmin:rmax+1, cmin:cmax+1]\n    \n    # RGBA\n    rgba = np.zeros\\(\\(bbox_h, bbox_w, 4\\), dtype=np.uint8\\)\n    rgba[:,:,:3] = crop_rgb\n    rgba[:,:,3] = crop_alpha\n    \n    # Save\n    filepath = os.path.join\\(base_dir, f\"highlight_{region_name}.png\"\\)\n    Image.fromarray\\(rgba\\).save\\(filepath, optimize=True\\)\n    fsize = os.path.getsize\\(filepath\\)\n    total_size += fsize\n    \n    # Metadata\n    norm_x = cmin / MAP_W\n    norm_y = rmin / MAP_H\n    norm_w = bbox_w / MAP_W\n    norm_h = bbox_h / MAP_H\n    \n    metadata[region_name] = {\n        \"hit_id\": rid,\n        \"display\": region_name,\n        \"bbox\": [int\\(cmin\\), int\\(rmin\\), int\\(cmax\\), int\\(rmax\\)],\n        \"norm_bbox\": [round\\(norm_x, 4\\), round\\(norm_y, 4\\), round\\(norm_w, 4\\), round\\(norm_h, 4\\)]\n    }\n    \n    pixel_count = int\\(\\(mask > 0\\).sum\\(\\)\\)\n    print\\(f\"  [{rid:2d}] {region_name:12s}: {bbox_w:4d}x{bbox_h:4d} \\({fsize/1024:.0f} KB, {pixel_count} px\\)\"\\)\n\n# Save metadata\nwith open\\(os.path.join\\(base_dir, \"regions_meta.json\"\\), \"w\"\\) as f:\n    json.dump\\(metadata, f, indent=2\\)\n\nprint\\(f\"\\\\nTotal: {len\\(region_ids\\)} pieces, {total_size/1024/1024:.1f} MB on disk\"\\)\n\n# Verify Region_17 alpha\ntest_img = np.array\\(Image.open\\(os.path.join\\(base_dir, \"highlight_Region_17.png\"\\)\\)\\)\nalpha_t = test_img[:,:,3]\nprint\\(f\"\\\\nRegion_17 alpha check:\"\\)\nprint\\(f\"  Full opaque \\(255\\): {\\(alpha_t==255\\).sum\\(\\)}\"\\)\nprint\\(f\"  Semi-transparent \\(1-254\\): {\\(\\(alpha_t>0\\)&\\(alpha_t<255\\)\\).sum\\(\\)}\"\\)\nprint\\(f\"  Transparent \\(0\\): {\\(alpha_t==0\\).sum\\(\\)}\"\\)\nprint\\(f\"  Dimensions: {test_img.shape[1]}x{test_img.shape[0]}\"\\)\n\nprint\\(\"\\\\nDone!\"\\)\nPYEOF)",
      "Bash(cmd /c 'dir \"\"D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\"\"')",
      "Bash(where /r \"C:\\\\Program Files \\(x86\\)\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\" Newtonsoft.Json.dll)",
      "Bash(echo:*)",
      "Bash(sort:*)",
      "Bash(grep:*)",
      "Bash(\"C:/Work/Sources/github/LOTRAOM_FactionMap/Tools/match_regions.py\" << 'PYEOF'\nimport cv2\nimport numpy as np\nfrom PIL import Image\nfrom scipy import ndimage\nimport json\nimport os\n\nLABEL_MAP = \"C:/Work/Sources/github/LOTRAOM_FactionMap/Tools/claudeweb/kingdom_label_map.png\"\nREGION_JSON = \"C:/Work/Sources/github/LOTRAOM_FactionMap/Tools/claudeweb/region_data.json\"\nPLAIN_MAP = \"C:/Work/Sources/github/LOTRAOM_FactionMap/Keyforce_Map_no-colours.jpg\"\nCOLOURS_MAP = \"C:/Work/Sources/github/LOTRAOM_FactionMap/Keyforce_Map_colours.jpg\"\nREGIONS_FILE = \"C:/Work/Sources/github/LOTRAOM_FactionMap/ModuleData/regions.json\"\n\nPADDING = 8\n\n# Load files\nprint\\(\"Loading files...\"\\)\nlabel_img = cv2.imread\\(LABEL_MAP, cv2.IMREAD_UNCHANGED\\)\next_h, ext_w = label_img.shape[:2]\nprint\\(f\"  Label map: {ext_w}x{ext_h}, dtype={label_img.dtype}\"\\)\n\nwith open\\(REGION_JSON, \"r\"\\) as f:\n    region_data = json.load\\(f\\)\n\nplain_img = Image.open\\(PLAIN_MAP\\)\nplain_arr = np.array\\(plain_img\\)\nfull_h, full_w = plain_arr.shape[:2]\nprint\\(f\"  Plain map: {full_w}x{full_h}\"\\)\n\ncolours_arr = np.array\\(Image.open\\(COLOURS_MAP\\)\\)\ncolours_ext = cv2.resize\\(colours_arr, \\(ext_w, ext_h\\), interpolation=cv2.INTER_LANCZOS4\\)\n\n# ============================================================\n# STEP 1b: Density-adaptive erosion cleanup\n# ============================================================\nprint\\(\"Running density-adaptive erosion cleanup...\"\\)\nEROSION_KERNEL = cv2.getStructuringElement\\(cv2.MORPH_ELLIPSE, \\(5, 5\\)\\)\nFILL_THRESHOLD = 0.30\ntotal_orphans = 0\norig_unique = set\\(np.unique\\(label_img\\)\\) - {0}\n\nfor kid in orig_unique:\n    mask = \\(label_img == kid\\).astype\\(np.uint8\\)\n    total_px = mask.sum\\(\\)\n    rows = np.any\\(mask, axis=1\\)\n    cols = np.any\\(mask, axis=0\\)\n    if not rows.any\\(\\):\n        continue\n    rmin, rmax = np.where\\(rows\\)[0][[0, -1]]\n    cmin, cmax = np.where\\(cols\\)[0][[0, -1]]\n    bbox_area = \\(cmax - cmin + 1\\) * \\(rmax - rmin + 1\\)\n    fill_ratio = total_px / bbox_area\n    if fill_ratio >= FILL_THRESHOLD:\n        continue\n    if fill_ratio < 0.05:\n        iters = 4\n    elif fill_ratio < 0.20:\n        iters = 3\n    else:\n        iters = 2\n    eroded = cv2.erode\\(mask, EROSION_KERNEL, iterations=iters\\)\n    eroded_px = eroded.sum\\(\\)\n    if eroded_px == 0:\n        continue\n    n_components, cc_labels = cv2.connectedComponents\\(eroded\\)\n    if n_components <= 2:\n        continue\n    best_cc = 0\n    best_size = 0\n    for cc_id in range\\(1, n_components\\):\n        sz = \\(cc_labels == cc_id\\).sum\\(\\)\n        if sz > best_size:\n            best_size = sz\n            best_cc = cc_id\n    kept_eroded = \\(cc_labels == best_cc\\).astype\\(np.uint8\\)\n    kept_dilated = cv2.dilate\\(kept_eroded, EROSION_KERNEL, iterations=iters + 2\\)\n    keep_mask = mask & kept_dilated\n    orphan_mask = \\(mask > 0\\) & \\(keep_mask == 0\\)\n    orphan_count = orphan_mask.sum\\(\\)\n    if orphan_count > 0:\n        label_img[orphan_mask] = 0\n        total_orphans += orphan_count\n\nif total_orphans > 0:\n    unassigned = \\(label_img == 0\\)\n    assigned = ~unassigned\n    if assigned.any\\(\\) and unassigned.any\\(\\):\n        _, nearest_idx = ndimage.distance_transform_edt\\(unassigned, return_indices=True\\)\n        label_img[unassigned] = label_img[nearest_idx[0][unassigned], nearest_idx[1][unassigned]]\n    print\\(f\"  {total_orphans:,} orphan pixels reassigned\"\\)\nelse:\n    print\\(\"  No cleanup needed\"\\)\n\n# ============================================================\n# STEP 1c: Color-distance cleanup\n# ============================================================\nprint\\(\"Running color-distance cleanup...\"\\)\nCOLOR_DIST_THRESHOLD = 60\ntotal_color_orphans = 0\nfor kid in set\\(np.unique\\(label_img\\)\\) - {0}:\n    mask = \\(label_img == kid\\)\n    total_px = mask.sum\\(\\)\n    if total_px < 500:\n        continue\n    region_colors = colours_ext[mask].astype\\(np.float32\\)\n    avg_color = np.median\\(region_colors, axis=0\\)\n    diff = region_colors - avg_color\n    dists = np.sqrt\\(\\(diff ** 2\\).sum\\(axis=1\\)\\)\n    outlier_indices = dists > COLOR_DIST_THRESHOLD\n    if not outlier_indices.any\\(\\):\n        continue\n    region_ys, region_xs = np.where\\(mask\\)\n    outlier_ys = region_ys[outlier_indices]\n    outlier_xs = region_xs[outlier_indices]\n    mask_uint8 = mask.astype\\(np.uint8\\)\n    interior = cv2.erode\\(mask_uint8, cv2.getStructuringElement\\(cv2.MORPH_ELLIPSE, \\(5, 5\\)\\), iterations=3\\)\n    periphery = mask_uint8 - interior\n    outlier_map = np.zeros_like\\(mask\\)\n    outlier_map[outlier_ys, outlier_xs] = True\n    remove_map = outlier_map & \\(periphery > 0\\)\n    remove_count = remove_map.sum\\(\\)\n    if remove_count > 0 and remove_count < total_px * 0.5:\n        label_img[remove_map] = 0\n        total_color_orphans += remove_count\n\nif total_color_orphans > 0:\n    unassigned = \\(label_img == 0\\)\n    assigned = ~unassigned\n    if assigned.any\\(\\) and unassigned.any\\(\\):\n        _, nearest_idx = ndimage.distance_transform_edt\\(unassigned, return_indices=True\\)\n        label_img[unassigned] = label_img[nearest_idx[0][unassigned], nearest_idx[1][unassigned]]\n    print\\(f\"  {total_color_orphans:,} color-outlier pixels reassigned\"\\)\nelse:\n    print\\(\"  No color outliers found\"\\)\n\n# ============================================================\n# STEP 1d: Morphological opening\n# ============================================================\nprint\\(\"Running morphological opening...\"\\)\nOPENING_KERNEL = cv2.getStructuringElement\\(cv2.MORPH_ELLIPSE, \\(7, 7\\)\\)\ntotal_protrusion_px = 0\nfor kid in set\\(np.unique\\(label_img\\)\\) - {0}:\n    mask = \\(label_img == kid\\).astype\\(np.uint8\\)\n    total_px = mask.sum\\(\\)\n    if total_px < 500:\n        continue\n    opened = cv2.morphologyEx\\(mask, cv2.MORPH_OPEN, OPENING_KERNEL\\)\n    removed = mask - opened\n    removed_count = removed.sum\\(\\)\n    if removed_count > 0 and removed_count < total_px * 0.5:\n        label_img[removed > 0] = 0\n        total_protrusion_px += removed_count\n\nif total_protrusion_px > 0:\n    unassigned = \\(label_img == 0\\)\n    assigned = ~unassigned\n    if assigned.any\\(\\) and unassigned.any\\(\\):\n        _, nearest_idx = ndimage.distance_transform_edt\\(unassigned, return_indices=True\\)\n        label_img[unassigned] = label_img[nearest_idx[0][unassigned], nearest_idx[1][unassigned]]\n    print\\(f\"  {total_protrusion_px:,} thin-protrusion pixels reassigned\"\\)\nelse:\n    print\\(\"  No thin protrusions found\"\\)\n\n# ============================================================\n# STEP 2: Upscale to full resolution\n# ============================================================\nprint\\(\"Upscaling label map...\"\\)\nlabel_full = cv2.resize\\(label_img, \\(full_w, full_h\\), interpolation=cv2.INTER_NEAREST\\)\n\n# Skip IDs\nSKIP_IDS = set\\(\\)\nfor k in region_data[\"kingdoms\"]:\n    if k[\"area_percent\"] > 15:\n        SKIP_IDS.add\\(k[\"id\"]\\)\n        break\nSKIP_IDS.add\\(39\\)\nprint\\(f\"Skip IDs: {SKIP_IDS}\"\\)\n\n# ============================================================\n# Compute Region_N -> norm_bbox\n# ============================================================\nprint\\(\"Computing Region_N bboxes...\"\\)\nregion_n_data = {}\nfaction_id = 0\nfor k in region_data[\"kingdoms\"]:\n    kid = k[\"id\"]\n    if kid in SKIP_IDS:\n        continue\n    faction_id += 1\n    faction_key = f\"Region_{faction_id}\"\n\n    full_mask = \\(label_full == kid\\)\n    rows = np.any\\(full_mask, axis=1\\)\n    cols = np.any\\(full_mask, axis=0\\)\n    if not rows.any\\(\\):\n        continue\n\n    rmin, rmax = np.where\\(rows\\)[0][[0, -1]]\n    cmin, cmax = np.where\\(cols\\)[0][[0, -1]]\n\n    x1 = max\\(0, int\\(cmin\\) - PADDING\\)\n    y1 = max\\(0, int\\(rmin\\) - PADDING\\)\n    x2 = min\\(full_w, int\\(cmax\\) + 1 + PADDING\\)\n    y2 = min\\(full_h, int\\(rmax\\) + 1 + PADDING\\)\n    bw, bh = x2 - x1, y2 - y1\n\n    norm_x = round\\(x1 / full_w, 4\\)\n    norm_y = round\\(y1 / full_h, 4\\)\n    norm_w = round\\(bw / full_w, 4\\)\n    norm_h = round\\(bh / full_h, 4\\)\n\n    region_n_data[faction_key] = {\n        \"bbox\": [norm_x, norm_y, norm_w, norm_h],\n        \"extractor_id\": kid,\n    }\n\nprint\\(f\"  Computed {len\\(region_n_data\\)} Region_N entries\"\\)\n\n# ============================================================\n# Load regions.json and match\n# ============================================================\nwith open\\(REGIONS_FILE, \"r\"\\) as f:\n    regions = json.load\\(f\\)\nprint\\(f\"  regions.json has {len\\(regions\\)} entries\"\\)\n\n# Match by closest BBox \\(greedy, in order of Region_N\\)\nprint\\(\\)\nprint\\(\"Region_N -> snake_case_key mapping:\"\\)\nprint\\(\"=\" * 80\\)\nmapping = {}\nused_snake_keys = set\\(\\)\n\nfor region_n in sorted\\(region_n_data.keys\\(\\), key=lambda x: int\\(x.split\\(\"_\"\\)[1]\\)\\):\n    data = region_n_data[region_n]\n    bbox = data[\"bbox\"]\n    ext_id = data[\"extractor_id\"]\n    best_match = None\n    best_dist = float\\(\"inf\"\\)\n    for snake_key, rdata in regions.items\\(\\):\n        if snake_key in used_snake_keys:\n            continue\n        rbbox = rdata[\"norm_bbox\"]\n        dist = sum\\(abs\\(float\\(bbox[i]\\) - rbbox[i]\\) for i in range\\(4\\)\\)\n        if dist < best_dist:\n            best_dist = dist\n            best_match = snake_key\n\n    status = \"\"\n    if best_dist >= 0.02:\n        status = \" ** UNCERTAIN **\"\n\n    mapping[region_n] = {\"snake_key\": best_match, \"extractor_id\": ext_id, \"dist\": best_dist}\n    used_snake_keys.add\\(best_match\\)\n\n    print\\(f\"  {region_n:12s} -> {best_match:35s} ext_id={ext_id:2d} dist={best_dist:.4f}{status}\"\\)\n\n# Unmatched snake_keys\nall_snake = set\\(regions.keys\\(\\)\\)\nunused = all_snake - used_snake_keys\nif unused:\n    print\\(f\"\\\\nUnmatched snake_case keys: {unused}\"\\)\n\n# Extra Region_N \\(37 regions vs 36 in regions.json\\)\nprint\\(f\"\\\\nTotal mapped: {len\\(mapping\\)}/{len\\(region_n_data\\)}\"\\)\nprint\\(f\"regions.json entries: {len\\(regions\\)}\"\\)\n\n# Output Python dict\nprint\\(\"\\\\n\\\\nPython dict for pipeline:\"\\)\nprint\\(\"REGION_N_TO_SNAKE = {\"\\)\nfor rn in sorted\\(mapping.keys\\(\\), key=lambda x: int\\(x.split\\(\"_\"\\)[1]\\)\\):\n    m = mapping[rn]\n    dist_note = f\"  # ext_id={m['extractor_id']}, dist={m['dist']:.4f}\"\n    if m[\"dist\"] >= 0.02:\n        dist_note += \" UNCERTAIN\"\n    print\\(f'    \"{rn}\": \"{m[\"snake_key\"]}\",{dist_note}'\\)\nprint\\(\"}\"\\)\nPYEOF)",
      "Bash(cmd.exe /c 'dir /s /b \"\"D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\\"\"')",
      "Bash(printenv:*)",
      "Bash(stat:*)",
      "Bash(cmd /c \"cd /d \"\"D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\SandBox\\\\GUI\"\" && dir /s /b *.xml\")",
      "Bash(py -c:*)",
      "Bash(\"C:/Program Files/AILocal/python/3.10/python.exe\" --version)",
      "Bash(\"C:/Program Files/AILocal/python/3.10/python.exe\" -c \"from PIL import Image; print\\(''PIL OK''\\)\")",
      "Bash(\"C:/Program Files/AILocal/python/3.10/python.exe\" -m pip install Pillow numpy)",
      "Bash(\"C:/Program Files/AILocal/python/3.10/python.exe\":*)",
      "Bash(\"C:/Program Files/AILocal/python/3.10/python.exe\" \"C:/Work/Sources/github/LOTRAOM_FactionMap/extract_banners.py\")",
      "Bash(\"C:/Program Files/AILocal/python/3.10/python.exe\" -c:*)",
      "Bash(\"C:/Program Files/AILocal/python/3.10/python.exe\" -c \"\nfrom PIL import Image, ImageDraw\nimport os\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\nbanners = sorted\\([f for f in os.listdir\\(outdir\\) if f.startswith\\(''banner_''\\) and f != ''banner_flag.png'']\\)\ncols = 6; scale = 3\nrows_needed = \\(len\\(banners\\) + cols - 1\\) // cols\ntile_w, tile_h = 80 * scale, 128 * scale; margin = 8\nsheet_w = cols * \\(tile_w + margin\\) + margin\nsheet_h = rows_needed * \\(tile_h + margin\\) + margin\nsheet = Image.new\\(''RGBA'', \\(sheet_w, sheet_h\\), \\(30, 30, 30, 255\\)\\)\ndraw = ImageDraw.Draw\\(sheet\\)\nfor idx, fname in enumerate\\(banners\\):\n    r = idx // cols; c = idx % cols\n    x = margin + c * \\(tile_w + margin\\); y = margin + r * \\(tile_h + margin\\)\n    img = Image.open\\(os.path.join\\(outdir, fname\\)\\).convert\\(''RGBA''\\)\n    bw, bh = img.size\n    img_big = img.resize\\(\\(bw * scale, bh * scale\\), Image.NEAREST\\)\n    bw2, bh2 = img_big.size\n    px = x + \\(tile_w - bw2\\) // 2; py = y + \\(tile_h - bh2\\) // 2\n    draw.rectangle\\([px-1, py-1, px+bw2, py+bh2], outline=\\(255,0,0,255\\)\\)\n    sheet.paste\\(img_big, \\(px, py\\), img_big\\)\nsheet.save\\(r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_contact_sheet6.png''\\)\nprint\\(''Sheet done''\\)\n\")",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\analyze_cells.py\" << 'PYEOF'\nimport sys\nsys.stdout.reconfigure\\(encoding='utf-8'\\)\n\nfrom PIL import Image\nimport numpy as np\n\nbase = r'C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap'\nimg = Image.open\\(f'{base}\\\\\\\\Gemini_Generated_Image_3500x03500x03500 \\(1\\).png'\\).convert\\('RGBA'\\)\narr = np.array\\(img\\)\nprint\\(f\"Composite size: {arr.shape[1]}x{arr.shape[0]}\"\\)\n\n# Grid params\nnum_cols = 11\nrow_bounds = [\\(23, 460\\), \\(530, 946\\), \\(1035, 1430\\)]\ncol_w = arr.shape[1] / num_cols\n\n# For each cell, find the actual banner boundaries by looking for non-dark content\n# Dark = average brightness < 40\nfor row_idx, \\(y1, y2\\) in enumerate\\(row_bounds\\):\n    for col_idx in range\\(num_cols\\):\n        x1 = int\\(col_idx * col_w\\)\n        x2 = int\\(\\(col_idx + 1\\) * col_w\\)\n        cell = arr[y1:y2, x1:x2, :3]\n        ch, cw = cell.shape[:2]\n        \n        # Find brightness per column \\(average across height\\)\n        col_brightness = np.mean\\(cell, axis=\\(0, 2\\)\\)  # shape: \\(cw,\\)\n        \n        # Find left and right edges where brightness > 50\n        bright_cols = np.where\\(col_brightness > 50\\)[0]\n        if len\\(bright_cols\\) == 0:\n            print\\(f\"[{row_idx},{col_idx}] EMPTY - no bright content\"\\)\n            continue\n        \n        left = bright_cols[0]\n        right = bright_cols[-1]\n        content_width = right - left + 1\n        center = \\(left + right\\) / 2\n        \n        # Also check row brightness for top/bottom\n        row_brightness = np.mean\\(cell, axis=\\(1, 2\\)\\)  # shape: \\(ch,\\)\n        bright_rows = np.where\\(row_brightness > 50\\)[0]\n        top = bright_rows[0] if len\\(bright_rows\\) > 0 else 0\n        bottom = bright_rows[-1] if len\\(bright_rows\\) > 0 else ch-1\n        content_height = bottom - top + 1\n        \n        # Mean brightness of center region\n        cx1 = max\\(0, int\\(center - content_width*0.3\\)\\)\n        cx2 = min\\(cw, int\\(center + content_width*0.3\\)\\)\n        center_brightness = np.mean\\(cell[top:bottom, cx1:cx2]\\)\n        \n        print\\(f\"[{row_idx},{col_idx}] cell={cw}x{ch} content: x={left}-{right} \\({content_width}px, {content_width/cw*100:.0f}%\\) y={top}-{bottom} \\({content_height}px\\) center_bright={center_brightness:.0f} offset_from_center={center/cw*100-50:.1f}%\"\\)\nPYEOF)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\analyze_cells.py\")",
      "Bash(cmd /c \"type nul > C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_cell_debug_script.py\")",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_cell_debug_script.py\" << 'PYEOF'\nimport sys, os\nsys.stdout.reconfigure\\(encoding='utf-8'\\)\nfrom PIL import Image\nimport numpy as np\n\nbase = r'C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap'\ntmpdir = os.path.join\\(base, '_cell_debug'\\)\nos.makedirs\\(tmpdir, exist_ok=True\\)\n\nimg = Image.open\\(os.path.join\\(base, 'Gemini_Generated_Image_3500x03500x03500 \\(1\\).png'\\)\\).convert\\('RGBA'\\)\narr = np.array\\(img\\)\nprint\\(f\"Composite: {arr.shape[1]}x{arr.shape[0]}\"\\)\n\nnum_cols = 11\nrow_bounds = [\\(23, 460\\), \\(530, 946\\), \\(1035, 1430\\)]\ncol_w = arr.shape[1] / num_cols\n\n# Also create a contact sheet showing all cells with grid lines\nfor row_idx, \\(y1, y2\\) in enumerate\\(row_bounds\\):\n    for col_idx in range\\(num_cols\\):\n        x1 = int\\(col_idx * col_w\\)\n        x2 = int\\(\\(col_idx + 1\\) * col_w\\)\n        cell = arr[y1:y2, x1:x2]\n        \n        # Save raw cell\n        cell_img = Image.fromarray\\(cell\\)\n        cell_img.save\\(os.path.join\\(tmpdir, f'cell_{row_idx}_{col_idx}.png'\\)\\)\n\n# Now also create the current 60% center-crop versions for comparison\nfor row_idx, \\(y1, y2\\) in enumerate\\(row_bounds\\):\n    for col_idx in range\\(num_cols\\):\n        x1 = int\\(col_idx * col_w\\)\n        x2 = int\\(\\(col_idx + 1\\) * col_w\\)\n        cell = arr[y1:y2, x1:x2]\n        ch, cw = cell.shape[:2]\n        \n        crop_pct = 0.60\n        margin = int\\(cw * \\(1.0 - crop_pct\\) / 2\\)\n        cropped = cell[:, margin:cw-margin]\n        \n        crop_img = Image.fromarray\\(cropped[:,:,:3]\\).convert\\('RGBA'\\)\n        crop_img = crop_img.resize\\(\\(72, 128\\), Image.LANCZOS\\)\n        result = np.array\\(crop_img\\)\n        result[:,:,3] = 255\n        Image.fromarray\\(result\\).save\\(os.path.join\\(tmpdir, f'crop_{row_idx}_{col_idx}.png'\\)\\)\n\nprint\\(f\"Saved cells and crops to {tmpdir}\"\\)\nprint\\(\"Done\"\\)\nPYEOF)",
      "Bash(cmd /c \"\"\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\"\" \"\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_cell_debug_script.py\"\"\")",
      "Bash(cmd /c \"\"\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\"\" \"\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_cell_debug_script.py\"\" 2>&1\")",
      "Bash(cmd /c \"dir C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_cell_debug\\\\*.png 2>&1\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_cell_debug_script.py\")",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\analyze_pink.py\" << 'PYEOF'\nimport sys, os\nsys.stdout.reconfigure\\(encoding='utf-8'\\)\nfrom PIL import Image\nimport numpy as np\n\nbase = r'C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap'\nimg = Image.open\\(os.path.join\\(base, 'flags_small_33.PNG'\\)\\).convert\\('RGBA'\\)\narr = np.array\\(img\\)\nh, w = arr.shape[:2]\nprint\\(f\"Image size: {w}x{h}\"\\)\n\n# Detect pink pixels: R > 200, G < 100, B > 150 \\(magenta range\\)\nr, g, b = arr[:,:,0], arr[:,:,1], arr[:,:,2]\nis_pink = \\(r > 180\\) & \\(g < 120\\) & \\(b > 140\\)\n\n# Find rows that are mostly pink \\(>80% pink\\) - these are the gaps between banner rows\nrow_pink_pct = np.mean\\(is_pink, axis=1\\)\nprint\\(\"\\\\nRow pink percentage \\(sampled\\):\"\\)\nfor y in range\\(0, h, 10\\):\n    bar = '#' * int\\(row_pink_pct[y] * 50\\)\n    print\\(f\"  y={y:4d}: {row_pink_pct[y]:.2f} {bar}\"\\)\n\n# Find horizontal separators \\(rows that are >90% pink\\)\nseparator_rows = np.where\\(row_pink_pct > 0.90\\)[0]\nif len\\(separator_rows\\) > 0:\n    # Find gaps in separator rows to identify row boundaries\n    gaps = np.where\\(np.diff\\(separator_rows\\) > 1\\)[0]\n    print\\(f\"\\\\nSeparator row ranges:\"\\)\n    start = separator_rows[0]\n    for gap_idx in gaps:\n        end = separator_rows[gap_idx]\n        print\\(f\"  y={start}-{end} \\(pink band\\)\"\\)\n        start = separator_rows[gap_idx + 1]\n    end = separator_rows[-1]\n    print\\(f\"  y={start}-{end} \\(pink band\\)\"\\)\n\n# Similarly for columns\ncol_pink_pct = np.mean\\(is_pink, axis=0\\)\nprint\\(\"\\\\nColumn pink percentage \\(sampled\\):\"\\)\nfor x in range\\(0, w, 20\\):\n    bar = '#' * int\\(col_pink_pct[x] * 50\\)\n    print\\(f\"  x={x:4d}: {col_pink_pct[x]:.2f} {bar}\"\\)\n\n# Find vertical separators \\(columns that are >80% pink\\) \nseparator_cols = np.where\\(col_pink_pct > 0.70\\)[0]\nif len\\(separator_cols\\) > 0:\n    gaps = np.where\\(np.diff\\(separator_cols\\) > 1\\)[0]\n    print\\(f\"\\\\nSeparator column ranges:\"\\)\n    start = separator_cols[0]\n    for gap_idx in gaps:\n        end = separator_cols[gap_idx]\n        print\\(f\"  x={start}-{end} \\(pink band, width={end-start+1}\\)\"\\)\n        start = separator_cols[gap_idx + 1]\n    end = separator_cols[-1]\n    print\\(f\"  x={start}-{end} \\(pink band, width={end-start+1}\\)\"\\)\n\nprint\\(\"\\\\nDone\"\\)\nPYEOF)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\analyze_pink.py\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -m pip install scipy)",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\find_banners.py\" << 'PYEOF'\nimport sys, os\nsys.stdout.reconfigure\\(encoding='utf-8'\\)\nfrom PIL import Image\nimport numpy as np\n\nbase = r'C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap'\nimg = Image.open\\(os.path.join\\(base, 'flags_small_33.PNG'\\)\\).convert\\('RGBA'\\)\narr = np.array\\(img\\)\nh, w = arr.shape[:2]\nprint\\(f\"Image: {w}x{h}\"\\)\n\n# Create pink mask - generous range for the magenta background\nr, g, b = arr[:,:,0], arr[:,:,1], arr[:,:,2]\nis_pink = \\(r.astype\\(int\\) - b.astype\\(int\\)\\).astype\\(float\\)  # pink has R~=B, high\n# Better: check if pixel is close to magenta \\(#FF69B4 range or #FF00FF range\\)\n# The pink in the image looks like a hot pink / magenta\n# Let's check actual pink pixel values\npink_samples = []\nfor y in [5, 10, h-5]:\n    for x in [5, 10, w-5]:\n        if True:  # edges should be pink\n            pink_samples.append\\(\\(arr[y,x,0], arr[y,x,1], arr[y,x,2]\\)\\)\nprint\\(f\"Pink samples \\(corners\\): {pink_samples}\"\\)\n\n# Pink detection: R > 180, G < 150, B > 130, and R-G > 80\nis_pink = \\(arr[:,:,0].astype\\(int\\) > 180\\) & \\(arr[:,:,1].astype\\(int\\) < 150\\) & \\(arr[:,:,2].astype\\(int\\) > 130\\) & \\(\\(arr[:,:,0].astype\\(int\\) - arr[:,:,1].astype\\(int\\)\\) > 60\\)\nnot_pink = ~is_pink\n\n# Also exclude the text labels \\(they're between banner bottom and next row\\)\n# The labels are dark text on pink, so they'd be detected as non-pink\n# Let's ignore that for now and focus on the larger objects\n\n# Use scipy.ndimage.label for connected component analysis\nfrom scipy import ndimage\n\n# Label connected non-pink regions\nlabeled, num_features = ndimage.label\\(not_pink\\)\nprint\\(f\"Found {num_features} connected non-pink regions\"\\)\n\n# Get bounding box for each region\nobjects = ndimage.find_objects\\(labeled\\)\n\n# Filter: only keep objects that are banner-sized \\(at least 30x50 pixels\\)\nbanners = []\nfor i, slc in enumerate\\(objects\\):\n    if slc is None:\n        continue\n    y_slice, x_slice = slc\n    obj_h = y_slice.stop - y_slice.start\n    obj_w = x_slice.stop - x_slice.start\n    obj_area = np.sum\\(labeled[slc] == \\(i+1\\)\\)\n    if obj_h > 50 and obj_w > 30 and obj_area > 2000:\n        banners.append\\({\n            'idx': i+1,\n            'x1': x_slice.start, 'y1': y_slice.start,\n            'x2': x_slice.stop, 'y2': y_slice.stop,\n            'w': obj_w, 'h': obj_h,\n            'area': obj_area\n        }\\)\n\n# Sort by y then x\nbanners.sort\\(key=lambda b: \\(b['y1'], b['x1']\\)\\)\n\nprint\\(f\"\\\\nFound {len\\(banners\\)} banner-sized objects:\"\\)\nfor i, b in enumerate\\(banners\\):\n    print\\(f\"  #{i:2d}: x={b['x1']:4d}-{b['x2']:4d} y={b['y1']:4d}-{b['y2']:4d}  size={b['w']}x{b['h']}  area={b['area']}\"\\)\n\n# Group into rows based on y position\nrows = []\ncurrent_row = [banners[0]] if banners else []\nfor b in banners[1:]:\n    if b['y1'] > current_row[-1]['y1'] + 100:  # new row if >100px gap\n        rows.append\\(current_row\\)\n        current_row = [b]\n    else:\n        current_row.append\\(b\\)\nif current_row:\n    rows.append\\(current_row\\)\n\nprint\\(f\"\\\\n{len\\(rows\\)} rows detected:\"\\)\nfor ri, row in enumerate\\(rows\\):\n    print\\(f\"  Row {ri}: {len\\(row\\)} banners, y range: {row[0]['y1']}-{row[0]['y2']}\"\\)\n    for b in row:\n        print\\(f\"    x={b['x1']:4d}-{b['x2']:4d}  {b['w']}x{b['h']}\"\\)\nPYEOF)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\find_banners.py\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\extract_banners.py\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\analyze_pink2.py\")",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\check_overlap.py\" << 'PYTHON_EOF'\nimport sys, os\nsys.stdout.reconfigure\\(encoding='utf-8'\\)\nfrom PIL import Image\nimport numpy as np\n\nbase = r'C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap'\nimg = Image.open\\(os.path.join\\(base, 'flags_small_33.PNG'\\)\\).convert\\('RGBA'\\)\narr = np.array\\(img\\)\n\nr = arr[:,:,0].astype\\(np.int16\\)\ng = arr[:,:,1].astype\\(np.int16\\)\nb = arr[:,:,2].astype\\(np.int16\\)\nis_pink = \\(r > 160\\) & \\(g < 150\\) & \\(\\(r - g\\) > 50\\) & \\(b > 100\\) & \\(b < 220\\)\n\n# Harad is [0,1], row 0 = y 26-423, col 1\ncol_w = arr.shape[1] / 11\nx1 = int\\(1 * col_w\\)\nx2 = int\\(2 * col_w\\)\n\nprint\\(f\"Harad cell [0,1]: x={x1}-{x2}, width={x2-x1}\"\\)\n\n# Check left edge of Harad cell - how many columns from the left are non-pink?\n# \\(these would be Rhun's banner bleeding in\\)\nfor dx in range\\(40\\):\n    x = x1 + dx\n    col_pink_pct = np.mean\\(is_pink[26:423, x]\\)\n    non_pink_pct = 1.0 - col_pink_pct\n    if non_pink_pct > 0.05:\n        # Check what color the non-pink pixels are\n        non_pink_mask = ~is_pink[26:423, x]\n        if np.any\\(non_pink_mask\\):\n            avg_color = np.mean\\(arr[26:423, x][non_pink_mask][:, :3], axis=0\\)\n            print\\(f\"  x={x} \\(offset +{dx}\\): non_pink={non_pink_pct:.2f}, avg_color=\\({avg_color[0]:.0f},{avg_color[1]:.0f},{avg_color[2]:.0f}\\)\"\\)\n\n# Now check Angmar [2,8] right edge\nprint\\(f\"\\\\nAngmar cell [2,8]:\"\\)\nx1_a = int\\(8 * col_w\\)\nx2_a = int\\(9 * col_w\\)\nprint\\(f\"  x={x1_a}-{x2_a}\"\\)\n\n# Check right edge\nfor dx in range\\(40\\):\n    x = x2_a - 1 - dx\n    col_pink_pct = np.mean\\(is_pink[1037:1427, x]\\)\n    non_pink_pct = 1.0 - col_pink_pct\n    if non_pink_pct > 0.05:\n        non_pink_mask = ~is_pink[1037:1427, x]\n        if np.any\\(non_pink_mask\\):\n            avg_color = np.mean\\(arr[1037:1427, x][non_pink_mask][:, :3], axis=0\\)\n            print\\(f\"  x={x} \\(offset -{dx} from right\\): non_pink={non_pink_pct:.2f}, avg_color=\\({avg_color[0]:.0f},{avg_color[1]:.0f},{avg_color[2]:.0f}\\)\"\\)\n\n# Also check: where does the pink gap between Rhun and Harad start/end?\nprint\\(f\"\\\\nPink gap between Rhun [0,0] and Harad [0,1]:\"\\)\nx_rhun_end = int\\(1 * col_w\\)  # nominal boundary\nfor x in range\\(x_rhun_end - 30, x_rhun_end + 30\\):\n    pct = np.mean\\(is_pink[26:423, x]\\)\n    if 0.3 < pct < 0.99:\n        print\\(f\"  x={x}: pink={pct:.2f} \\({'<-- boundary' if x == x_rhun_end else ''}\\)\"\\)\nPYTHON_EOF)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\check_overlap.py\")",
      "Bash(\"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\map_banners.py\" << 'PYEOF'\nimport sys, os\nsys.stdout.reconfigure\\(encoding='utf-8'\\)\nfrom PIL import Image\nimport numpy as np\n\nbase = r'C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap'\noutdir = os.path.join\\(base, '_cell_debug'\\)\nos.makedirs\\(outdir, exist_ok=True\\)\n\nimg = Image.open\\(os.path.join\\(base, 'Gemini_Generated_Image_3500x03500x03500 \\(1\\).png'\\)\\).convert\\('RGBA'\\)\narr = np.array\\(img\\)\nh, w = arr.shape[:2]\nprint\\(f\"Composite: {w}x{h}\"\\)\n\nrow_bounds = [\\(23, 460\\), \\(530, 946\\), \\(1035, 1430\\)]\nnum_cols = 11\ncol_w = w / num_cols\n\n# For each cell, find where the actual banner content is\n# by looking at brightness profiles from left and right\nfor ri, \\(y1, y2\\) in enumerate\\(row_bounds\\):\n    for ci in range\\(num_cols\\):\n        x1 = int\\(ci * col_w\\)\n        x2 = int\\(\\(ci + 1\\) * col_w\\)\n        cell = arr[y1:y2, x1:x2]\n        ch, cw = cell.shape[:2]\n        \n        # Save raw cell\n        cell_img = Image.fromarray\\(cell\\)\n        cell_img.save\\(os.path.join\\(outdir, f'cell_r{ri}_c{ci:02d}_raw.png'\\)\\)\n        \n        # Save 4x zoomed cell \\(nearest neighbor to see exact pixels\\)\n        zoomed = cell_img.resize\\(\\(cw * 4, ch * 4\\), Image.NEAREST\\)\n        zoomed.save\\(os.path.join\\(outdir, f'cell_r{ri}_c{ci:02d}_4x.png'\\)\\)\n        \n        # Brightness per column\n        brightness = np.mean\\(cell[:,:,:3], axis=\\(0,2\\)\\)  # avg brightness per column\n        \n        # Find first/last column with brightness > 25 \\(non-background\\)\n        bright_cols = np.where\\(brightness > 25\\)[0]\n        if len\\(bright_cols\\) > 0:\n            left = bright_cols[0]\n            right = bright_cols[-1]\n            \n            # Also per row\n            row_brightness = np.mean\\(cell[:,:,:3], axis=\\(1,2\\)\\)\n            bright_rows = np.where\\(row_brightness > 25\\)[0]\n            top = bright_rows[0] if len\\(bright_rows\\) > 0 else 0\n            bottom = bright_rows[-1] if len\\(bright_rows\\) > 0 else ch-1\n            \n            # Absolute coords in composite\n            abs_x1 = x1 + left\n            abs_x2 = x1 + right + 1\n            abs_y1 = y1 + top\n            abs_y2 = y1 + bottom + 1\n            \n            banner_w = right - left + 1\n            banner_h = bottom - top + 1\n            aspect = banner_h / banner_w if banner_w > 0 else 0\n            \n            print\\(f\"[{ri},{ci}] cell=\\({x1},{y1}\\)-\\({x2},{y2}\\) banner=\\({abs_x1},{abs_y1}\\)-\\({abs_x2},{abs_y2}\\) size={banner_w}x{banner_h} aspect={aspect:.2f}\"\\)\n        else:\n            print\\(f\"[{ri},{ci}] EMPTY\"\\)\nPYEOF)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\map_banners.py\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"import sys; sys.stdout.reconfigure\\(encoding=''utf-8''\\); f=open\\(r''C:\\\\Users\\\\yotth\\\\.claude\\\\projects\\\\C--Work-Sources-github-LOTRAOM-FactionMap\\\\137d478c-8d56-4ab6-8cc0-7fbe61399fbd.jsonl'',''r'',encoding=''utf-8''\\); lines=f.readlines\\(\\); f.close\\(\\); print\\(f''Total lines: {len\\(lines\\)}''\\)\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c:*)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nimport sys, json\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\nwith open\\(r''C:\\\\Users\\\\yotth\\\\.claude\\\\projects\\\\C--Work-Sources-github-LOTRAOM-FactionMap\\\\137d478c-8d56-4ab6-8cc0-7fbe61399fbd.jsonl'',''r'',encoding=''utf-8''\\) as f:\n    lines = f.readlines\\(\\)\n\n# Search for user messages about flags/banners\nfor i, line in enumerate\\(lines\\):\n    try:\n        obj = json.loads\\(line\\)\n        if isinstance\\(obj, dict\\):\n            msg = obj.get\\(''message'', {}\\)\n            if isinstance\\(msg, dict\\):\n                role = msg.get\\(''role'', ''''\\)\n                content = msg.get\\(''content'', ''''\\)\n                if isinstance\\(content, list\\):\n                    # might be multi-part message\n                    for part in content:\n                        if isinstance\\(part, dict\\) and part.get\\(''type''\\) == ''text'':\n                            text = part.get\\(''text'', ''''\\)\n                            if role == ''user'' and \\(''flagge'' in text.lower\\(\\) or ''banner'' in text.lower\\(\\) or ''kaputt'' in text.lower\\(\\) or ''heile'' in text.lower\\(\\)\\):\n                                print\\(f''Line {i} [user]: {text[:300]}''\\)\n                                print\\(\\)\n    except:\n        pass\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\":*)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nimport sys, json\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\nwith open\\(r''C:\\\\Users\\\\yotth\\\\.claude\\\\projects\\\\C--Work-Sources-github-LOTRAOM-FactionMap\\\\137d478c-8d56-4ab6-8cc0-7fbe61399fbd.jsonl'',''r'',encoding=''utf-8''\\) as f:\n    lines = f.readlines\\(\\)\n\n# Search lines 12000-15200 for extract_banners.py write operations\nfor i, line in enumerate\\(lines\\):\n    if i < 12000 or i > 15200:\n        continue\n    try:\n        obj = json.loads\\(line\\)\n        if isinstance\\(obj, dict\\):\n            msg = obj.get\\(''message'', {}\\)\n            if isinstance\\(msg, dict\\):\n                content = msg.get\\(''content'', ''''\\)\n                if isinstance\\(content, list\\):\n                    for part in content:\n                        if isinstance\\(part, dict\\):\n                            if part.get\\(''type''\\) == ''tool_use'' and part.get\\(''name''\\) == ''Write'':\n                                inp = part.get\\(''input'', {}\\)\n                                fp = inp.get\\(''file_path'', ''''\\)\n                                if ''extract_banners'' in fp:\n                                    code = inp.get\\(''content'', ''''\\)\n                                    print\\(f''Line {i}: Write extract_banners.py''\\)\n                                    # Show first 500 chars\n                                    print\\(code[:800]\\)\n                                    print\\(''---END---''\\)\n                                    print\\(\\)\n    except:\n        pass\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nimport sys, json\nsys.stdout.reconfigure\\(encoding=''utf-8''\\)\nwith open\\(r''C:\\\\Users\\\\yotth\\\\.claude\\\\projects\\\\C--Work-Sources-github-LOTRAOM-FactionMap\\\\137d478c-8d56-4ab6-8cc0-7fbe61399fbd.jsonl'',''r'',encoding=''utf-8''\\) as f:\n    lines = f.readlines\\(\\)\n\nobj = json.loads\\(lines[14515]\\)\nmsg = obj.get\\(''message'', {}\\)\ncontent = msg.get\\(''content'', ''''\\)\nif isinstance\\(content, list\\):\n    for part in content:\n        if isinstance\\(part, dict\\) and part.get\\(''type''\\) == ''tool_use'' and part.get\\(''name''\\) == ''Write'':\n            code = part.get\\(''input'', {}\\).get\\(''content'', ''''\\)\n            print\\(code\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"from PIL import Image; import os; d=''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''; [print\\(f''{f}: {Image.open\\(os.path.join\\(d,f\\)\\).size}''\\) for f in sorted\\(os.listdir\\(d\\)\\) if f.startswith\\(''banner_''\\)]\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np, os\n\nbase = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap''\nimg = Image.open\\(os.path.join\\(base, ''Gemini_Generated_Image_3500x03500x03500 \\(1\\).png''\\)\\).convert\\(''RGBA''\\)\narr = np.array\\(img\\)\nprint\\(f''Composite size: {img.size}''\\)  # \\(W, H\\)\n\n# Row bounds from previous analysis\nrows = [\\(23, 460\\), \\(530, 946\\), \\(1035, 1430\\)]\nfor i, \\(y1, y2\\) in enumerate\\(rows\\):\n    print\\(f''Row {i}: y={y1}-{y2}, height={y2-y1}''\\)\n\n# Check Mordor cell \\(0, 5\\)\ncol_w = img.size[0] / 11\nci = 5\nx1 = int\\(ci * col_w\\)\nx2 = int\\(\\(ci + 1\\) * col_w\\)\nprint\\(f''Mordor cell: x={x1}-{x2}, y=23-460''\\)\nprint\\(f''Cell size: {x2-x1}x{460-23}''\\)\n\n# Save the raw Mordor cell for inspection\ncell = arr[23:460, x1:x2]\nImage.fromarray\\(cell\\).save\\(os.path.join\\(base, ''debug_mordor_cell.png''\\)\\)\nprint\\(''Saved debug_mordor_cell.png''\\)\n\n# Also check: what''s BELOW row 0? Maybe banners extend further\n# Check brightness below y=460\nstripe = arr[450:480, x1:x2]\nbrightness = np.max\\(stripe[:, :, :3], axis=2\\)\nfor y in range\\(30\\):\n    avg = np.mean\\(brightness[y]\\)\n    print\\(f''  y={450+y}: avg brightness={avg:.1f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np, os\n\nbase = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap''\nimg = Image.open\\(os.path.join\\(base, ''Gemini_Generated_Image_3500x03500x03500 \\(1\\).png''\\)\\).convert\\(''RGBA''\\)\narr = np.array\\(img\\)\n\nrows = [\\(23, 460\\), \\(530, 946\\), \\(1035, 1430\\)]\ncol_w = arr.shape[1] / 11\n\n# Analyze a few cells to understand vertical content bounds\nfor name, ri, ci in [\\(''Mordor'', 0, 5\\), \\(''Rhun'', 0, 0\\), \\(''Gondor'', 0, 3\\), \\(''Isengard'', 0, 10\\), \\(''Misty'', 2, 0\\)]:\n    y1, y2 = rows[ri]\n    x1 = int\\(ci * col_w\\)\n    x2 = int\\(\\(ci+1\\) * col_w\\)\n    cell = arr[y1:y2, x1:x2]\n    ch, cw = cell.shape[:2]\n    \n    # Center crop 60%\n    margin = int\\(cw * 0.20\\)\n    cropped = cell[:, margin:cw-margin]\n    \n    # Find vertical content: rows where brightness > threshold\n    brightness = np.max\\(cropped[:, :, :3], axis=2\\)\n    row_max = np.max\\(brightness, axis=1\\)\n    row_mean = np.mean\\(brightness, axis=1\\)\n    \n    # Find first and last row with significant content\n    # Use column-wise analysis: find columns that aren''t pure black\n    content_rows = row_max > 15\n    if np.any\\(content_rows\\):\n        first_content = np.argmax\\(content_rows\\)\n        last_content = ch - np.argmax\\(content_rows[::-1]\\) - 1\n        print\\(f''{name}: cell={cw}x{ch}, crop={cropped.shape[1]}x{ch}, content y={first_content}-{last_content} \\(h={last_content-first_content+1}\\)''\\)\n        # What''s the aspect ratio of the actual content?\n        content_h = last_content - first_content + 1\n        content_w = cropped.shape[1]\n        print\\(f''  Content area: {content_w}x{content_h}, aspect={content_w/content_h:.2f}''\\)\n    else:\n        print\\(f''{name}: no content found''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np, os\n\nbase = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap''\nimg = Image.open\\(os.path.join\\(base, ''flags_small_33.PNG''\\)\\).convert\\(''RGBA''\\)\narr = np.array\\(img\\)\n\n# Sample pink background from known empty areas \\(corners, between rows\\)\n# Top-left corner area\ncorner = arr[0:20, 0:20, :3]\nprint\\(f''Top-left corner avg RGB: {corner.mean\\(axis=\\(0,1\\)\\):.0f}''\\)\nprint\\(f''Top-left corner pixel 5,5: {arr[5, 5, :3]}''\\)\n\n# Between row 0 and row 1 \\(y=423-531\\)\ngap = arr[460:520, 100:200, :3]\nprint\\(f''Gap between rows avg RGB: {gap.mean\\(axis=\\(0,1\\)\\):.0f}''\\)\nprint\\(f''Gap pixel: {arr[480, 150, :3]}''\\)\n\n# Right edge \\(should be pink bg\\)\nedge = arr[200:300, 2800:2816, :3]\nprint\\(f''Right edge avg RGB: {edge.mean\\(axis=\\(0,1\\)\\):.0f}''\\)\n\n# Sample from within a cell where we know it''s pink bg \\(Mordor cell edges\\)\nrows_pink = [\\(26, 423\\), \\(531, 935\\), \\(1037, 1427\\)]\ncol_w = 2816 / 11\n# Mordor \\(0,5\\) - far left edge should be pink\nci = 5\nx1 = int\\(ci * col_w\\)\nprint\\(f''Mordor cell left edge pixel: {arr[200, x1+5, :3]}''\\)\nprint\\(f''Mordor cell left edge pixel: {arr[200, x1+10, :3]}''\\)\n# Right edge of Mordor cell\nx2 = int\\(\\(ci+1\\) * col_w\\)\nprint\\(f''Mordor cell right edge pixel: {arr[200, x2-5, :3]}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np, os\n\nbase = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap''\nimg = Image.open\\(os.path.join\\(base, ''flags_small_33.PNG''\\)\\).convert\\(''RGBA''\\)\narr = np.array\\(img\\)\n\n# Sample pink from known spots\nprint\\(''Top-left 5,5:'', arr[5, 5, :3]\\)\nprint\\(''Gap row 480,150:'', arr[480, 150, :3]\\)\nprint\\(''Right edge 200,2810:'', arr[200, 2810, :3]\\)\n\n# Mordor cell edges\ncol_w = 2816 / 11\nci = 5\nx1 = int\\(ci * col_w\\)\nx2 = int\\(\\(ci+1\\) * col_w\\)\nprint\\(''Mordor left+5:'', arr[200, x1+5, :3]\\)\nprint\\(''Mordor left+15:'', arr[200, x1+15, :3]\\)\nprint\\(''Mordor right-5:'', arr[200, x2-5, :3]\\)\n\n# Check what''s at the very center of a pink gap\n# Between Gondor\\(3\\) and col 4 \\(BROKEN\\)\nci_gap = 4\nx_gap = int\\(ci_gap * col_w\\) + int\\(col_w // 2\\)\nprint\\(f''Gap cell center \\({x_gap}\\): {arr[200, x_gap, :3]}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np, os\n\nbase = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap''\nimg_pink = Image.open\\(os.path.join\\(base, ''flags_small_33.PNG''\\)\\).convert\\(''RGBA''\\)\narr = np.array\\(img_pink\\)\n\npink_rows = [\\(26, 423\\), \\(531, 935\\), \\(1037, 1427\\)]\ncol_w = 2816 / 11\nPINK = np.array\\([214, 92, 141], dtype=np.float32\\)\n\n# For each cell, check what % is NOT pink \\(=flag content\\)\nfor name, ri, ci in [\\(''Rhun'',0,0\\), \\(''Harad'',0,1\\), \\(''Gondor'',0,3\\), \\(''Mordor'',0,5\\),\n                      \\(''Isengard'',0,10\\), \\(''Misty'',2,0\\), \\(''Arthedain'',2,2\\)]:\n    y1, y2 = pink_rows[ri]\n    x1 = int\\(ci * col_w\\)\n    x2 = int\\(\\(ci+1\\) * col_w\\)\n    cell = arr[y1:y2, x1:x2]\n    ch, cw = cell.shape[:2]\n    \n    dist = np.sqrt\\(np.sum\\(\\(cell[:, :, :3].astype\\(np.float32\\) - PINK\\)**2, axis=2\\)\\)\n    is_pink = dist < 80\n    not_pink = ~is_pink\n    \n    # For each column, check if it has significant flag content\n    col_content = np.mean\\(not_pink, axis=0\\)  # fraction of non-pink per column\n    \n    # Flag extent: leftmost and rightmost column with >50% non-pink\n    flag_cols = col_content > 0.5\n    if np.any\\(flag_cols\\):\n        left = np.argmax\\(flag_cols\\)\n        right = cw - np.argmax\\(flag_cols[::-1]\\) - 1\n        flag_w = right - left + 1\n        print\\(f''{name}: cell={cw}px, flag={flag_w}px \\({left}-{right}\\), flag/cell={100*flag_w/cw:.0f}%''\\)\n    else:\n        print\\(f''{name}: no flag found''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport os\nd = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\flags''\nfor f in sorted\\(os.listdir\\(d\\)\\):\n    if f.endswith\\(''.png''\\):\n        img = Image.open\\(os.path.join\\(d, f\\)\\)\n        print\\(f''{f}: {img.size}, mode={img.mode}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\process_flags.py\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport os\n\n# Find the newest image in flags dir - likely the composite\nd = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\flags''\nfiles = sorted\\(os.listdir\\(d\\)\\)\nfor f in files:\n    fp = os.path.join\\(d, f\\)\n    img = Image.open\\(fp\\)\n    print\\(f''{f}: {img.size}, mode={img.mode}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nimport shutil, os, glob\nsrc = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\ndst = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\ncount = 0\nfor f in glob.glob\\(os.path.join\\(src, ''banner_*.png''\\)\\):\n    shutil.copy2\\(f, dst\\)\n    count += 1\nprint\\(f''Copied {count} banner files to game directory''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nimport shutil, os, glob\nsrc = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\ndst = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\ncount = 0\nfor f in glob.glob\\(os.path.join\\(src, ''banner_*.png''\\)\\):\n    shutil.copy2\\(f, dst\\)\n    count += 1\nprint\\(f''Copied {count} banners to game directory''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\n\n# Check the Rohan cell from 22_52_32 \\(6-strip, cell index 1\\)\nimg = Image.open\\(r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\flags\\\\ChatGPT Image 10. Feb. 2026, 22_52_32.png''\\)\narr = np.array\\(img.convert\\(''RGB''\\)\\)\nh, w = arr.shape[:2]\n\n# This is a 6-banner horizontal strip\n# Rohan is cell 1\nbrightness = np.max\\(arr[:, :, :3], axis=2\\)\ncol_brightness = np.mean\\(brightness, axis=0\\)\nis_gap = col_brightness < 12\n\n# Find segments\nsegments = []\nseg_start = 0\nin_gap = False\nfor x in range\\(w\\):\n    if is_gap[x] and not in_gap:\n        if x - seg_start > 20:\n            segments.append\\(\\(seg_start, x\\)\\)\n        in_gap = True\n    elif not is_gap[x] and in_gap:\n        seg_start = x\n        in_gap = False\nif not in_gap and w - seg_start > 20:\n    segments.append\\(\\(seg_start, w\\)\\)\n\nprint\\(f''Segments: {segments}''\\)\n# Cell 1 = Rohan\nif len\\(segments\\) > 1:\n    x1, x2 = segments[1]\n    cell = arr[:, x1:x2]\n    ch, cw = cell.shape[:2]\n    print\\(f''Rohan cell: {cw}x{ch}''\\)\n    \n    # Check bottom rows\n    cell_brightness = np.max\\(cell[:, :, :3], axis=2\\)\n    row_brightness = np.mean\\(cell_brightness, axis=1\\)\n    for y in range\\(ch-80, ch\\):\n        print\\(f''  y={y}: avg={row_brightness[y]:.1f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\n\nimg = Image.open\\(r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\\\\banner_kingdom_of_rohan.png''\\).convert\\(''RGBA''\\)\narr = np.array\\(img\\)\n# Check bottom 20 rows\nfor y in range\\(108, 128\\):\n    row = arr[y, :, :]\n    avg_r = np.mean\\(row[:, 0]\\)\n    avg_g = np.mean\\(row[:, 1]\\)\n    avg_b = np.mean\\(row[:, 2]\\)\n    avg_a = np.mean\\(row[:, 3]\\)\n    print\\(f''y={y}: R={avg_r:.0f} G={avg_g:.0f} B={avg_b:.0f} A={avg_a:.0f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\n\n# 22_52_32 is the 6-strip with labels\nimg = Image.open\\(r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\flags\\\\ChatGPT Image 10. Feb. 2026, 22_52_32.png''\\)\narr = np.array\\(img.convert\\(''RGB''\\)\\)\nh, w = arr.shape[:2]\nprint\\(f''6-strip: {w}x{h}''\\)\n\n# Split into segments\nbrightness = np.max\\(arr[:, :, :3], axis=2\\)\ncol_brightness = np.mean\\(brightness, axis=0\\)\nis_gap = col_brightness < 12\nsegments = []\nseg_start = 0\nin_gap = False\nfor x in range\\(w\\):\n    if is_gap[x] and not in_gap:\n        if x - seg_start > 20:\n            segments.append\\(\\(seg_start, x\\)\\)\n        in_gap = True\n    elif not is_gap[x] and in_gap:\n        seg_start = x\n        in_gap = False\nif not in_gap and w - seg_start > 20:\n    segments.append\\(\\(seg_start, w\\)\\)\n\n# Cell 1 = Rohan\nx1, x2 = segments[1]\ncell = arr[:, x1:x2]\nch, cw = cell.shape[:2]\nprint\\(f''Rohan cell: {cw}x{ch}''\\)\n\n# Find where banner ends and label starts\ncell_brightness = np.max\\(cell[:, :, :3], axis=2\\)\nrow_brightness = np.mean\\(cell_brightness, axis=1\\)\n\n# Show rows around the label area\nfor y in range\\(int\\(ch*0.75\\), ch\\):\n    if row_brightness[y] > 1:\n        print\\(f''  y={y} \\({100*y/ch:.0f}%\\): avg={row_brightness[y]:.1f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\n\nimg = Image.open\\(r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\\\\banner_kingdom_of_rohan.png''\\).convert\\(''RGBA''\\)\n# Save at 8x for close inspection  \nimg.resize\\(\\(672, 1024\\), Image.NEAREST\\).save\\(r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\debug_rohan_8x.png''\\)\nprint\\(''Saved''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\n\n# Check the ACTUAL output banner pixel by pixel at the bottom\nimg = Image.open\\(r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap\\\\banner_kingdom_of_rohan.png''\\).convert\\(''RGBA''\\)\narr = np.array\\(img\\)\n\n# Bottom 30 rows, check alpha\nfor y in range\\(98, 128\\):\n    visible = np.sum\\(arr[y, :, 3] > 10\\)\n    if visible > 0:\n        avg_rgb = np.mean\\(arr[y, arr[y, :, 3] > 10, :3], axis=0\\) if visible > 0 else [0,0,0]\n        print\\(f''  y={y}: {visible} visible px, avg RGB=\\({avg_rgb[0]:.0f},{avg_rgb[1]:.0f},{avg_rgb[2]:.0f}\\)''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage\nimport os\n\nflags_dir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\flags''\n\ncomposite_map = {\n    ''ChatGPT Image 10. Feb. 2026, 22_47_13.png'': [''gondor'',''iron_hills'',''angmar''],\n    ''ChatGPT Image 10. Feb. 2026, 22_49_19.png'': [''rhun'',''harad'',''khand'',''mordor''],\n    ''ChatGPT Image 10. Feb. 2026, 22_52_32.png'': [''anduin'',''rohan'',''arthedain'',''erebor'',''lothlorien'',''lindon''],\n    ''ChatGPT Image 10. Feb. 2026, 22_58_26.png'': [''gundabad'',''gundabad2'',''isengard'',''umbar''],\n    ''ChatGPT Image 10. Feb. 2026, 23_02_35.png'': [''misty'',''ered_luin_orcs'',''forochel''],\n    ''ChatGPT Image 10. Feb. 2026, 23_03_33.png'': [''misty2'',''gwaer'',''narager''],\n    ''ChatGPT Image 10. Feb. 2026, 23_05_35.png'': [''dale'',''dorwinion'',''dunland''],\n    ''ChatGPT Image 10. Feb. 2026, 23_06_32.png'': [''rhudaur'',''bellakar'',''cardolan''],\n    ''ChatGPT Image 10. Feb. 2026, 23_08_03.png'': [''rivendell'',''mirkwood'',''neldoreth''],\n}\n\nfor filename, names in composite_map.items\\(\\):\n    fp = os.path.join\\(flags_dir, filename\\)\n    if not os.path.exists\\(fp\\):\n        continue\n    img = Image.open\\(fp\\)\n    arr = np.array\\(img.convert\\(''RGB''\\)\\)\n    h, w = arr.shape[:2]\n    \n    brightness = np.max\\(arr[:,:,:3], axis=2\\)\n    col_brightness = np.mean\\(brightness, axis=0\\)\n    is_gap = col_brightness < 12\n    \n    if h > w:\n        # 2x2\n        cw, ch = w//2, h//2\n        cells = [\\(0,0,cw,ch\\),\\(cw,0,w,ch\\),\\(0,ch,cw,h\\),\\(cw,ch,w,h\\)]\n    else:\n        segments = []\n        seg_start = 0\n        in_gap = False\n        for x in range\\(w\\):\n            if is_gap[x] and not in_gap:\n                if x - seg_start > 20:\n                    segments.append\\(\\(seg_start, x\\)\\)\n                in_gap = True\n            elif not is_gap[x] and in_gap:\n                seg_start = x\n                in_gap = False\n        if not in_gap and w - seg_start > 20:\n            segments.append\\(\\(seg_start, w\\)\\)\n        cells = [\\(x1, 0, x2, h\\) for x1, x2 in segments]\n    \n    for i, name in enumerate\\(names\\):\n        if i >= len\\(cells\\):\n            break\n        x1, y1, x2, y2 = cells[i]\n        cell = arr[y1:y2, x1:x2]\n        cell_h, cell_w = cell.shape[:2]\n        \n        # Cut bottom 20% \\(label\\)\n        cut_h = int\\(cell_h * 0.80\\)\n        cell = cell[:cut_h]\n        \n        # Find content via flood fill\n        cell_rgba = np.dstack\\([cell, np.full\\(cell.shape[:2], 255, dtype=np.uint8\\)]\\)\n        bright = np.max\\(cell[:,:,:3], axis=2\\)\n        dark = bright < 25\n        seeds = np.zeros_like\\(dark\\)\n        seeds[0,:] = dark[0,:]\n        seeds[-1,:] = dark[-1,:]\n        seeds[:,0] = dark[:,0]\n        seeds[:,-1] = dark[:,-1]\n        labeled, _ = ndimage.label\\(dark\\)\n        seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n        bg_mask = np.zeros_like\\(dark\\)\n        for lbl in seed_labels:\n            bg_mask |= \\(labeled == lbl\\)\n        \n        content = ~bg_mask\n        rows_c = np.any\\(content, axis=1\\)\n        cols_c = np.any\\(content, axis=0\\)\n        if np.any\\(rows_c\\) and np.any\\(cols_c\\):\n            cy1 = np.argmax\\(rows_c\\)\n            cy2 = cell.shape[0] - np.argmax\\(rows_c[::-1]\\)\n            cx1 = np.argmax\\(cols_c\\)\n            cx2 = cell.shape[1] - np.argmax\\(cols_c[::-1]\\)\n            content_w = cx2 - cx1\n            content_h = cy2 - cy1\n            ratio = content_w / content_h\n            print\\(f''{name:15s}: cell={cell_w}x{cut_h}, content={content_w}x{content_h}, ratio={ratio:.2f}''\\)\n\")",
      "Bash(powershell.exe:*)",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\n# Only fix the 4 solid/Gemini banners\nsolid_banners = [\n    ''banner_clans_of_enedwaith.png'',\n    ''banner_dwarves_of_orocarni.png'', \n    ''banner_forodwaith.png'',\n    ''banner_shadow_of_dol_guldur.png'',\n]\n\nfor fname in solid_banners:\n    fpath = os.path.join\\(outdir, fname\\)\n    img = Image.open\\(fpath\\).convert\\(''RGBA''\\)\n    arr = np.array\\(img\\)\n    \n    # Step 1: flood-fill black from edges -> transparent\n    brightness = np.max\\(arr[:,:,:3], axis=2\\)\n    dark = brightness < 25\n    \n    seeds = np.zeros_like\\(dark\\)\n    seeds[0,:] = dark[0,:]\n    seeds[-1,:] = dark[-1,:]\n    seeds[:,0] = dark[:,0]\n    seeds[:,-1] = dark[:,-1]\n    \n    labeled, _ = ndimage.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    \n    arr[bg_mask, 3] = 0\n    \n    # Step 2: keep only largest connected component\n    content_mask = arr[:,:,3] > 10\n    labeled2, num_features = ndimage.label\\(content_mask\\)\n    if num_features > 0:\n        component_sizes = ndimage.sum\\(content_mask, labeled2, range\\(1, num_features+1\\)\\)\n        largest_label = np.argmax\\(component_sizes\\) + 1\n        banner_mask = labeled2 == largest_label\n        arr[~banner_mask, 3] = 0\n    \n    result = Image.fromarray\\(arr\\)\n    \n    # Stats\n    alpha = arr[:,:,3]\n    opaque_pct = np.mean\\(alpha > 200\\) * 100\n    transp_pct = np.mean\\(alpha < 10\\) * 100\n    print\\(f''{fname}: opaque={opaque_pct:.1f}%, transparent={transp_pct:.1f}%''\\)\n    \n    result.save\\(fpath, optimize=True\\)\n    print\\(f''  -> saved''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\n# User says these are OK:\nok_factions = [\n    ''dark_lands_of_mordor'', ''dwarves_of_erebor'', ''easterlings_of_rhun'', \n    ''elves_of_lindon'', ''elves_of_lothlorien'', ''elves_of_mirkwood'',\n    ''elves_of_neldoreth'', ''elves_of_rivendell'', ''faithful_of_bellakar'',\n    ''hill_men_of_dunland'', ''hill_men_of_rhudaur'', ''kingdom_of_arthedain'',\n    ''kingdom_of_dale'', ''kingdom_of_rohan'', ''dwarves_of_ered_luin'',\n    ''orcs_of_gwaer'', ''orcs_of_narager'', ''orcs_of_the_misty_mountains'',\n    ''realm_of_cardolan'', ''realm_of_dorwinion'', ''tribes_of_harad'',\n    ''vale_of_anduin'', ''variags_of_khand'',\n]\n\nall_factions = [\n    ''easterlings_of_rhun'', ''tribes_of_harad'', ''variags_of_khand'',\n    ''kingdom_of_gondor'', ''dark_lands_of_mordor'', ''dwarves_of_erebor'',\n    ''kingdom_of_dale'', ''elves_of_rivendell'', ''orcs_of_gundabad'',\n    ''dominion_of_isengard'', ''hill_men_of_dunland'', ''dwarves_of_orocarni'',\n    ''realm_of_dorwinion'', ''clans_of_enedwaith'', ''realm_of_cardolan'',\n    ''orcs_of_narager'', ''elves_of_lindon'', ''orcs_of_gwaer'',\n    ''faithful_of_bellakar'', ''dwarves_of_ered_luin'',\n    ''orcs_of_the_misty_mountains'', ''forodwaith'', ''kingdom_of_arthedain'',\n    ''hill_men_of_rhudaur'', ''vale_of_anduin'', ''orcs_of_ered_luin'',\n    ''elves_of_neldoreth'', ''orcs_of_forochel'', ''realm_of_angmar'',\n    ''fangorn_forest'', ''iron_hills'', ''havens_of_umbar'', ''kingdom_of_rohan'',\n    ''shadow_of_dol_guldur'', ''elves_of_lothlorien'', ''elves_of_mirkwood'',\n]\n\nbroken = [f for f in all_factions if f not in ok_factions]\nprint\\(''BROKEN banners \\({}/{}\\):''.format\\(len\\(broken\\), len\\(all_factions\\)\\)\\)\nfor f in sorted\\(set\\(broken\\)\\):\n    print\\(f''  - {f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nbroken = [\n    ''clans_of_enedwaith'', ''dominion_of_isengard'', ''dwarves_of_orocarni'',\n    ''fangorn_forest'', ''forodwaith'', ''havens_of_umbar'', ''iron_hills'',\n    ''kingdom_of_gondor'', ''orcs_of_ered_luin'', ''orcs_of_forochel'',\n    ''orcs_of_gundabad'', ''realm_of_angmar'', ''shadow_of_dol_guldur'',\n]\n\n# Create a comparison sheet: broken ones vs some good ones\ngood = [''dark_lands_of_mordor'', ''kingdom_of_rohan'', ''tribes_of_harad'', ''elves_of_rivendell'']\n\nall_names = broken + good\ncols = 5\nrows_needed = \\(len\\(all_names\\) + cols - 1\\) // cols\n\n# Each cell: 84 wide, 128+20 tall \\(20 for label\\)\ncell_w = 100\ncell_h = 150\nsheet_w = cols * cell_w\nsheet_h = rows_needed * cell_h\n\nsheet = Image.new\\(''RGBA'', \\(sheet_w, sheet_h\\), \\(40, 40, 40, 255\\)\\)\n\nfrom PIL import ImageDraw\ndraw = ImageDraw.Draw\\(sheet\\)\n\nfor idx, name in enumerate\\(all_names\\):\n    r = idx // cols\n    c = idx % cols\n    x = c * cell_w + \\(cell_w - 84\\) // 2\n    y = r * cell_h\n    \n    fpath = os.path.join\\(outdir, f''banner_{name}.png''\\)\n    img = Image.open\\(fpath\\).convert\\(''RGBA''\\)\n    \n    # Paste on gray bg\n    bg = Image.new\\(''RGBA'', \\(84, 128\\), \\(60, 60, 60, 255\\)\\)\n    bg = Image.alpha_composite\\(bg, img\\)\n    sheet.paste\\(bg, \\(x, y\\)\\)\n    \n    # Label\n    label = name.replace\\(''_'', '' ''\\)[:15]\n    prefix = ''BAD: '' if name in broken else ''OK: ''\n    color = \\(255, 80, 80\\) if name in broken else \\(80, 255, 80\\)\n    draw.text\\(\\(c * cell_w + 2, y + 130\\), prefix + label, fill=color\\)\n\nsheet.save\\(os.path.join\\(outdir, ''_comparison.png''\\)\\)\nprint\\(''Saved comparison sheet''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\n\"\"\"\"\"\"\nReprocess ONLY the 13 broken banners.\nDon''t touch the 23 good ones.\nKey fix: No more remove_label_area\\(\\) - let largest-component handle text removal.\n\"\"\"\"\"\"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os\n\nflags_dir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\flags''\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nCANVAS_W = 84\nCANVAS_H = 128\n\n# These are the 13 broken banners\nbroken_set = {\n    ''clans_of_enedwaith'', ''dominion_of_isengard'', ''dwarves_of_orocarni'',\n    ''fangorn_forest'', ''forodwaith'', ''havens_of_umbar'', ''iron_hills'',\n    ''kingdom_of_gondor'', ''orcs_of_ered_luin'', ''orcs_of_forochel'',\n    ''orcs_of_gundabad'', ''realm_of_angmar'', ''shadow_of_dol_guldur'',\n}\n\ndef make_black_transparent\\(img\\):\n    arr = np.array\\(img.convert\\(''RGBA''\\)\\)\n    brightness = np.max\\(arr[:,:,:3], axis=2\\)\n    dark = brightness < 25\n    seeds = np.zeros_like\\(dark\\)\n    seeds[0,:] = dark[0,:]\n    seeds[-1,:] = dark[-1,:]\n    seeds[:,0] = dark[:,0]\n    seeds[:,-1] = dark[:,-1]\n    labeled, _ = ndi.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    arr[bg_mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\n\ndef process_to_banner\\(img\\):\n    img = img.convert\\(''RGBA''\\)\n    img = make_black_transparent\\(img\\)\n    arr = np.array\\(img\\)\n    content_mask = arr[:,:,3] > 10\n    labeled, num_features = ndi.label\\(content_mask\\)\n    if num_features == 0:\n        return None\n    component_sizes = ndi.sum\\(content_mask, labeled, range\\(1, num_features+1\\)\\)\n    largest_label = np.argmax\\(component_sizes\\) + 1\n    banner_mask = labeled == largest_label\n    arr[~banner_mask, 3] = 0\n    \n    rows = np.any\\(banner_mask, axis=1\\)\n    cols = np.any\\(banner_mask, axis=0\\)\n    y1 = int\\(np.argmax\\(rows\\)\\)\n    y2 = int\\(arr.shape[0] - np.argmax\\(rows[::-1]\\)\\)\n    x1 = int\\(np.argmax\\(cols\\)\\)\n    x2 = int\\(arr.shape[1] - np.argmax\\(cols[::-1]\\)\\)\n    cropped = Image.fromarray\\(arr[y1:y2, x1:x2]\\)\n    \n    result = cropped.resize\\(\\(CANVAS_W, CANVAS_H\\), Image.LANCZOS\\)\n    return result\n\n\ndef split_composite_horizontal\\(img, num_banners\\):\n    arr = np.array\\(img.convert\\(''RGB''\\)\\)\n    h, w = arr.shape[:2]\n    brightness = np.max\\(arr[:,:,:3], axis=2\\)\n    col_brightness = np.mean\\(brightness, axis=0\\)\n    is_gap = col_brightness < 12\n    segments = []\n    seg_start = 0\n    in_gap = False\n    for x in range\\(w\\):\n        if is_gap[x] and not in_gap:\n            if x - seg_start > 20:\n                segments.append\\(\\(seg_start, x\\)\\)\n            in_gap = True\n        elif not is_gap[x] and in_gap:\n            seg_start = x\n            in_gap = False\n    if not in_gap and w - seg_start > 20:\n        segments.append\\(\\(seg_start, w\\)\\)\n    if len\\(segments\\) < num_banners:\n        cell_w = w // num_banners\n        segments = [\\(i * cell_w, \\(i+1\\) * cell_w\\) for i in range\\(num_banners\\)]\n    cells = []\n    for x1, x2 in segments[:num_banners]:\n        cells.append\\(img.crop\\(\\(x1, 0, x2, h\\)\\)\\)\n    return cells\n\n\ndef split_grid\\(img, rows, cols\\):\n    w, h = img.size\n    cell_w = w // cols\n    cell_h = h // rows\n    cells = []\n    for r in range\\(rows\\):\n        for c in range\\(cols\\):\n            x1 = c * cell_w\n            y1 = r * cell_h\n            cells.append\\(img.crop\\(\\(x1, y1, x1+cell_w, y1+cell_h\\)\\)\\)\n    return cells\n\n\n#  Source mappings \ncomposite_map = {\n    ''ChatGPT Image 10. Feb. 2026, 22_47_13.png'': [\n        ''kingdom_of_gondor'', ''iron_hills'', ''realm_of_angmar'',\n    ],\n    ''ChatGPT Image 10. Feb. 2026, 22_58_26.png'': [\n        ''orcs_of_gundabad'', ''orcs_of_gundabad'',\n        ''dominion_of_isengard'', ''havens_of_umbar'',\n    ],\n    ''ChatGPT Image 10. Feb. 2026, 23_02_35.png'': [\n        ''orcs_of_the_misty_mountains'', ''orcs_of_ered_luin'', ''orcs_of_forochel'',\n    ],\n}\n\ngrid_3x3_map = {\n    ''ChatGPT Image 10. Feb. 2026, 22_42_38.png'': [\n        ''realm_of_dorwinion'', ''tribes_of_harad'', ''kingdom_of_gondor'',\n        ''dwarves_of_erebor'', ''kingdom_of_rohan'', ''kingdom_of_arthedain'',\n        ''dwarves_of_ered_luin'', ''fangorn_forest'', ''elves_of_lindon'',\n    ],\n}\n\nprocessed = {}\n\n#  1. Process composites  only broken factions \nprint\\(''=== Reprocessing broken banners \\(no label cut\\) ===''\\)\n\nfor filename, factions in composite_map.items\\(\\):\n    filepath = os.path.join\\(flags_dir, filename\\)\n    if not os.path.exists\\(filepath\\):\n        continue\n    \n    img = Image.open\\(filepath\\)\n    w, h = img.size\n    \n    if h > w:\n        cells = split_grid\\(img, 2, 2\\)\n    else:\n        cells = split_composite_horizontal\\(img, len\\(factions\\)\\)\n    \n    for i, faction in enumerate\\(factions\\):\n        if i >= len\\(cells\\):\n            break\n        if faction not in broken_set:\n            continue\n        if faction in processed:\n            continue\n        \n        cell = cells[i]\n        # NO remove_label_area! Largest-component handles text\n        result = process_to_banner\\(cell\\)\n        if result:\n            result.save\\(os.path.join\\(outdir, f''banner_{faction}.png''\\), optimize=True\\)\n            processed[faction] = f''{filename}[{i}]''\n            print\\(f''  {faction} <- {filename}[{i}]''\\)\n\n#  2. 3x3 grid  only broken factions \nfor filename, factions in grid_3x3_map.items\\(\\):\n    filepath = os.path.join\\(flags_dir, filename\\)\n    if not os.path.exists\\(filepath\\):\n        continue\n    \n    img = Image.open\\(filepath\\)\n    cells = split_grid\\(img, 3, 3\\)\n    \n    for i, faction in enumerate\\(factions\\):\n        if i >= len\\(cells\\):\n            break\n        if faction not in broken_set:\n            continue\n        if faction in processed:\n            continue\n        \n        cell = cells[i]\n        result = process_to_banner\\(cell\\)\n        if result:\n            result.save\\(os.path.join\\(outdir, f''banner_{faction}.png''\\), optimize=True\\)\n            processed[faction] = f''{filename}[{i}]''\n            print\\(f''  {faction} <- {filename}[{i}]''\\)\n\n#  3. Gemini fallback for 4 that have no ChatGPT source \n# These don''t have ChatGPT composites, so keep from extract_banners but fix transparency\ngemini_only = broken_set - set\\(processed.keys\\(\\)\\)\nif gemini_only:\n    print\\(f''\\\\nGemini-only \\(no ChatGPT source\\): {gemini_only}''\\)\n    print\\(''These need new ChatGPT composites or manual treatment.''\\)\n\nprint\\(f''\\\\nReprocessed {len\\(processed\\)} broken banners''\\)\nprint\\(f''Still Gemini-only: {gemini_only}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image, ImageDraw\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nbroken = [\n    ''kingdom_of_gondor'', ''iron_hills'', ''realm_of_angmar'',\n    ''orcs_of_gundabad'', ''dominion_of_isengard'', ''havens_of_umbar'',\n    ''orcs_of_ered_luin'', ''orcs_of_forochel'', ''fangorn_forest'',\n]\n\n# Also show some known-good ones for comparison\ngood = [''dark_lands_of_mordor'', ''kingdom_of_rohan'', ''tribes_of_harad'', ''elves_of_rivendell'']\n\nall_names = broken + good\ncols = 5\nrows_needed = \\(len\\(all_names\\) + cols - 1\\) // cols\ncell_w = 100\ncell_h = 150\nsheet = Image.new\\(''RGBA'', \\(cols * cell_w, rows_needed * cell_h\\), \\(40, 40, 40, 255\\)\\)\ndraw = ImageDraw.Draw\\(sheet\\)\n\nfor idx, name in enumerate\\(all_names\\):\n    r = idx // cols\n    c = idx % cols\n    x = c * cell_w + \\(cell_w - 84\\) // 2\n    y = r * cell_h\n    \n    fpath = os.path.join\\(outdir, f''banner_{name}.png''\\)\n    img = Image.open\\(fpath\\).convert\\(''RGBA''\\)\n    bg = Image.new\\(''RGBA'', \\(84, 128\\), \\(60, 60, 60, 255\\)\\)\n    bg = Image.alpha_composite\\(bg, img\\)\n    sheet.paste\\(bg, \\(x, y\\)\\)\n    \n    label = name.replace\\(''_'', '' ''\\)[:16]\n    prefix = ''FIX: '' if name in broken else ''OK: ''\n    color = \\(255, 200, 80\\) if name in broken else \\(80, 255, 80\\)\n    draw.text\\(\\(c * cell_w + 2, y + 130\\), prefix + label, fill=color\\)\n\nsheet.save\\(os.path.join\\(outdir, ''_comparison_fixed.png''\\)\\)\nprint\\(''Saved comparison''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image, ImageDraw\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\n# Show all fixed ones on white background to see edges clearly\nfixed = [''kingdom_of_gondor'', ''iron_hills'', ''realm_of_angmar'',\n         ''dominion_of_isengard'', ''havens_of_umbar'', ''orcs_of_gundabad'',\n         ''fangorn_forest'', ''orcs_of_ered_luin'', ''orcs_of_forochel'']\ngood = [''dark_lands_of_mordor'', ''kingdom_of_rohan'', ''tribes_of_harad'']\n\nall_names = fixed + good\ncols = 4\nrows_needed = \\(len\\(all_names\\) + cols - 1\\) // cols\ncell_w = 100\ncell_h = 150\nsheet = Image.new\\(''RGBA'', \\(cols * cell_w, rows_needed * cell_h\\), \\(200, 200, 200, 255\\)\\)\ndraw = ImageDraw.Draw\\(sheet\\)\n\nfor idx, name in enumerate\\(all_names\\):\n    r = idx // cols\n    c = idx % cols\n    x = c * cell_w + \\(cell_w - 84\\) // 2\n    y = r * cell_h\n    \n    img = Image.open\\(os.path.join\\(outdir, f''banner_{name}.png''\\)\\).convert\\(''RGBA''\\)\n    # On white bg to see edges\n    bg = Image.new\\(''RGBA'', \\(84, 128\\), \\(220, 220, 220, 255\\)\\)\n    bg = Image.alpha_composite\\(bg, img\\)\n    sheet.paste\\(bg, \\(x, y\\)\\)\n    \n    short = name.split\\(''_''\\)[-1] if len\\(name\\) > 16 else name.replace\\(''_'','' ''\\)\n    color = \\(200, 50, 50\\) if name in fixed else \\(50, 150, 50\\)\n    draw.text\\(\\(c * cell_w + 2, y + 130\\), short[:14], fill=color\\)\n\nsheet.save\\(os.path.join\\(outdir, ''_edges_check.png''\\)\\)\nprint\\(''Saved edge check''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image, ImageDraw\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nnames = [''kingdom_of_gondor'', ''iron_hills'', ''realm_of_angmar'',\n         ''dominion_of_isengard'', ''havens_of_umbar'', ''orcs_of_gundabad'',\n         ''fangorn_forest'', ''orcs_of_ered_luin'', ''orcs_of_forochel'',\n         ''dark_lands_of_mordor'', ''kingdom_of_rohan'', ''tribes_of_harad'']\n\ncols = 4\nrows_needed = \\(len\\(names\\) + cols - 1\\) // cols\ncell_w = 100\ncell_h = 150\nsheet = Image.new\\(''RGBA'', \\(cols * cell_w, rows_needed * cell_h\\), \\(50, 50, 50, 255\\)\\)\ndraw = ImageDraw.Draw\\(sheet\\)\n\ngood_set = {''dark_lands_of_mordor'',''kingdom_of_rohan'',''tribes_of_harad''}\n\nfor idx, name in enumerate\\(names\\):\n    r = idx // cols\n    c = idx % cols\n    x = c * cell_w + \\(cell_w - 84\\) // 2\n    y = r * cell_h\n    \n    img = Image.open\\(os.path.join\\(outdir, f''banner_{name}.png''\\)\\).convert\\(''RGBA''\\)\n    bg = Image.new\\(''RGBA'', \\(84, 128\\), \\(50, 50, 50, 255\\)\\)\n    bg = Image.alpha_composite\\(bg, img\\)\n    sheet.paste\\(bg, \\(x, y\\)\\)\n    \n    short = name.replace\\(''kingdom_of_'',''''\\).replace\\(''realm_of_'',''''\\).replace\\(''dominion_of_'',''''\\).replace\\(''orcs_of_'',''o_''\\).replace\\(''havens_of_'',''''\\)\n    color = \\(80, 255, 80\\) if name in good_set else \\(255, 200, 80\\)\n    draw.text\\(\\(c * cell_w + 2, y + 130\\), short[:14], fill=color\\)\n\nsheet.save\\(os.path.join\\(outdir, ''_proportional_check.png''\\)\\)\nprint\\(''Done''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image, ImageDraw\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nnames = [''kingdom_of_gondor'', ''iron_hills'', ''realm_of_angmar'',\n         ''dominion_of_isengard'', ''havens_of_umbar'', ''orcs_of_gundabad'',\n         ''fangorn_forest'', ''orcs_of_ered_luin'', ''orcs_of_forochel'',\n         ''dark_lands_of_mordor'', ''kingdom_of_rohan'', ''tribes_of_harad'']\n\ncols = 4\nrows_n = 3\ncell_w = 100\ncell_h = 150\nsheet = Image.new\\(''RGBA'', \\(cols * cell_w, rows_n * cell_h\\), \\(40, 40, 40, 255\\)\\)\ndraw = ImageDraw.Draw\\(sheet\\)\ngood_set = {''dark_lands_of_mordor'',''kingdom_of_rohan'',''tribes_of_harad''}\n\nfor idx, name in enumerate\\(names\\):\n    r = idx // cols\n    c = idx % cols\n    x = c * cell_w + \\(cell_w - 84\\) // 2\n    y = r * cell_h\n    img = Image.open\\(os.path.join\\(outdir, f''banner_{name}.png''\\)\\).convert\\(''RGBA''\\)\n    bg = Image.new\\(''RGBA'', \\(84, 128\\), \\(40, 40, 40, 255\\)\\)\n    bg = Image.alpha_composite\\(bg, img\\)\n    sheet.paste\\(bg, \\(x, y\\)\\)\n    short = name.split\\(''_of_''\\)[-1] if ''_of_'' in name else name\n    color = \\(80, 255, 80\\) if name in good_set else \\(255, 200, 80\\)\n    draw.text\\(\\(c * cell_w + 2, y + 130\\), short[:14], fill=color\\)\n\nsheet.save\\(os.path.join\\(outdir, ''_stretch_v2.png''\\)\\)\nprint\\(''Done''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\n# Fix 4 Gemini banners - apply flood-fill transparency\ngemini_banners = [''clans_of_enedwaith'', ''dwarves_of_orocarni'', ''forodwaith'', ''shadow_of_dol_guldur'']\n\nCANVAS_W = 84\nCANVAS_H = 128\n\nfor name in gemini_banners:\n    fpath = os.path.join\\(outdir, f''banner_{name}.png''\\)\n    img = Image.open\\(fpath\\).convert\\(''RGBA''\\)\n    arr = np.array\\(img\\)\n    \n    # Flood-fill black from edges\n    brightness = np.max\\(arr[:,:,:3], axis=2\\)\n    dark = brightness < 30  # slightly higher threshold for Gemini\n    seeds = np.zeros_like\\(dark\\)\n    seeds[0,:] = dark[0,:]; seeds[-1,:] = dark[-1,:]\n    seeds[:,0] = dark[:,0]; seeds[:,-1] = dark[:,-1]\n    labeled, _ = ndi.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    arr[bg_mask, 3] = 0\n    \n    # Largest component\n    content_mask = arr[:,:,3] > 10\n    labeled2, num = ndi.label\\(content_mask\\)\n    if num > 0:\n        sizes = ndi.sum\\(content_mask, labeled2, range\\(1, num+1\\)\\)\n        largest = np.argmax\\(sizes\\) + 1\n        mask = labeled2 == largest\n        arr[~mask, 3] = 0\n        \n        # Re-crop and stretch to 84x128\n        rows = np.any\\(mask, axis=1\\)\n        cols = np.any\\(mask, axis=0\\)\n        y1 = int\\(np.argmax\\(rows\\)\\)\n        y2 = int\\(arr.shape[0] - np.argmax\\(rows[::-1]\\)\\)\n        x1 = int\\(np.argmax\\(cols\\)\\)\n        x2 = int\\(arr.shape[1] - np.argmax\\(cols[::-1]\\)\\)\n        cropped = Image.fromarray\\(arr[y1:y2, x1:x2]\\)\n        \n        cw, ch = cropped.size\n        result = cropped.resize\\(\\(CANVAS_W, CANVAS_H\\), Image.LANCZOS\\)\n        result.save\\(fpath, optimize=True\\)\n        \n        alpha = np.array\\(result\\)[:,:,3]\n        opaque_pct = np.mean\\(alpha > 200\\) * 100\n        print\\(f''{name}: content={cw}x{ch} -> 84x128, opaque={opaque_pct:.1f}%''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\nCANVAS_W = 84\nCANVAS_H = 128\n\n# Check what brightness threshold we need for Enedwaith\n# These are from extract_banners.py -> Gemini composites\n# The bg is not pure black but dark gray\n\nfor name in [''clans_of_enedwaith'']:\n    fpath = os.path.join\\(outdir, f''banner_{name}.png''\\)\n    img = Image.open\\(fpath\\).convert\\(''RGBA''\\)\n    arr = np.array\\(img\\)\n    brightness = np.max\\(arr[:,:,:3], axis=2\\)\n    \n    print\\(f''{name}:''\\)\n    for thresh in [20, 25, 30, 40, 50, 60]:\n        dark = brightness < thresh\n        pct = np.mean\\(dark\\) * 100\n        print\\(f''  pixels < {thresh}: {pct:.1f}%''\\)\n    \n    # Edge analysis\n    print\\(f''  corners: TL={brightness[0:3,0:3].mean\\(\\):.0f} TR={brightness[0:3,-3:].mean\\(\\):.0f} BL={brightness[-3:,0:3].mean\\(\\):.0f} BR={brightness[-3:,-3:].mean\\(\\):.0f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\fix_banners.py\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\n# First: re-process the GOOD banners with the original approach that worked\n# Original approach: make_black_transparent -> largest_component -> crop -> stretch\n# WITH label cut for labeled composites, WITHOUT for unlabeled\n\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os, shutil\n\nflags_dir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\flags''\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\ngamedir = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nCANVAS_W = 84\nCANVAS_H = 128\n\ndef make_black_transparent\\(img\\):\n    arr = np.array\\(img.convert\\(''RGBA''\\)\\)\n    brightness = np.max\\(arr[:,:,:3], axis=2\\)\n    dark = brightness < 25\n    seeds = np.zeros_like\\(dark\\)\n    seeds[0,:] = dark[0,:]; seeds[-1,:] = dark[-1,:]\n    seeds[:,0] = dark[:,0]; seeds[:,-1] = dark[:,-1]\n    labeled, _ = ndi.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    arr[bg_mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef process_original\\(img, cut_label=True\\):\n    img = img.convert\\(''RGBA''\\)\n    if cut_label:\n        h = img.size[1]\n        img = img.crop\\(\\(0, 0, img.size[0], int\\(h * 0.80\\)\\)\\)\n    img = make_black_transparent\\(img\\)\n    arr = np.array\\(img\\)\n    content_mask = arr[:,:,3] > 10\n    labeled, num = ndi.label\\(content_mask\\)\n    if num == 0: return None\n    sizes = ndi.sum\\(content_mask, labeled, range\\(1, num+1\\)\\)\n    largest = np.argmax\\(sizes\\) + 1\n    mask = labeled == largest\n    arr[~mask, 3] = 0\n    rows = np.any\\(mask, axis=1\\)\n    cols = np.any\\(mask, axis=0\\)\n    y1 = int\\(np.argmax\\(rows\\)\\)\n    y2 = int\\(arr.shape[0] - np.argmax\\(rows[::-1]\\)\\)\n    x1 = int\\(np.argmax\\(cols\\)\\)\n    x2 = int\\(arr.shape[1] - np.argmax\\(cols[::-1]\\)\\)\n    cropped = Image.fromarray\\(arr[y1:y2, x1:x2]\\)\n    return cropped.resize\\(\\(CANVAS_W, CANVAS_H\\), Image.LANCZOS\\)\n\ndef split_h\\(img, n\\):\n    arr = np.array\\(img.convert\\(''RGB''\\)\\)\n    h, w = arr.shape[:2]\n    brt = np.max\\(arr[:,:,:3], axis=2\\)\n    col_brt = np.mean\\(brt, axis=0\\)\n    is_gap = col_brt < 12\n    segs = []; ss = 0; ig = False\n    for x in range\\(w\\):\n        if is_gap[x] and not ig:\n            if x - ss > 20: segs.append\\(\\(ss, x\\)\\)\n            ig = True\n        elif not is_gap[x] and ig:\n            ss = x; ig = False\n    if not ig and w - ss > 20: segs.append\\(\\(ss, w\\)\\)\n    if len\\(segs\\) < n:\n        cw = w // n\n        segs = [\\(i*cw, \\(i+1\\)*cw\\) for i in range\\(n\\)]\n    return [img.crop\\(\\(x1, 0, x2, h\\)\\) for x1, x2 in segs[:n]]\n\ndef split_grid\\(img, rows, cols\\):\n    w, h = img.size\n    cw = w // cols; ch = h // rows\n    cells = []\n    for r in range\\(rows\\):\n        for c in range\\(cols\\):\n            cells.append\\(img.crop\\(\\(c*cw, r*ch, \\(c+1\\)*cw, \\(r+1\\)*ch\\)\\)\\)\n    return cells\n\n# GOOD composites - restore with original approach \\(labeled = with label cut\\)\ngood_composites = {\n    ''ChatGPT Image 10. Feb. 2026, 22_49_19.png'':\n        \\([''easterlings_of_rhun'', ''tribes_of_harad'', ''variags_of_khand'', ''dark_lands_of_mordor''], True\\),\n    ''ChatGPT Image 10. Feb. 2026, 22_52_32.png'':\n        \\([''vale_of_anduin'', ''kingdom_of_rohan'', ''kingdom_of_arthedain'', ''dwarves_of_erebor'', ''elves_of_lothlorien'', ''elves_of_lindon''], True\\),\n    ''ChatGPT Image 10. Feb. 2026, 23_03_33.png'':\n        \\([''orcs_of_the_misty_mountains'', ''orcs_of_gwaer'', ''orcs_of_narager''], True\\),\n    ''ChatGPT Image 10. Feb. 2026, 23_05_35.png'':\n        \\([''kingdom_of_dale'', ''realm_of_dorwinion'', ''hill_men_of_dunland''], True\\),\n    ''ChatGPT Image 10. Feb. 2026, 23_06_32.png'':\n        \\([''hill_men_of_rhudaur'', ''faithful_of_bellakar'', ''realm_of_cardolan''], True\\),\n    ''ChatGPT Image 10. Feb. 2026, 23_08_03.png'':\n        \\([''elves_of_rivendell'', ''elves_of_mirkwood'', ''elves_of_neldoreth''], True\\),\n    # These 3 have no labels - restore without label cut\n    ''ChatGPT Image 10. Feb. 2026, 22_47_13.png'':\n        \\([''kingdom_of_gondor'', ''iron_hills'', ''realm_of_angmar''], False\\),\n    # Labeled composites with some good banners\n    ''ChatGPT Image 10. Feb. 2026, 23_02_35.png'':\n        \\([''orcs_of_the_misty_mountains'', ''orcs_of_ered_luin'', ''orcs_of_forochel''], True\\),\n}\n\nprint\\(''=== Restoring GOOD banners with original approach ===''\\)\nrestored = {}\n\nfor filename, \\(factions, has_labels\\) in good_composites.items\\(\\):\n    filepath = os.path.join\\(flags_dir, filename\\)\n    if not os.path.exists\\(filepath\\): continue\n    img = Image.open\\(filepath\\)\n    w, h = img.size\n    if h > w:\n        cells = split_grid\\(img, 2, 2\\)\n    else:\n        cells = split_h\\(img, len\\(factions\\)\\)\n    for i, faction in enumerate\\(factions\\):\n        if i >= len\\(cells\\): break\n        if faction in restored: continue\n        result = process_original\\(cells[i], cut_label=has_labels\\)\n        if result:\n            result.save\\(os.path.join\\(outdir, f''banner_{faction}.png''\\), optimize=True\\)\n            restored[faction] = True\n            print\\(f''  {faction} <- {filename}[{i}] \\(original\\)''\\)\n\n# Also restore from 3x3 grid \\(no labels\\)\ngrid_file = ''ChatGPT Image 10. Feb. 2026, 22_42_38.png''\ngrid_factions = [''realm_of_dorwinion'', ''tribes_of_harad'', ''kingdom_of_gondor'',\n    ''dwarves_of_erebor'', ''kingdom_of_rohan'', ''kingdom_of_arthedain'',\n    ''dwarves_of_ered_luin'', ''fangorn_forest'', ''elves_of_lindon'']\nfilepath = os.path.join\\(flags_dir, grid_file\\)\nif os.path.exists\\(filepath\\):\n    img = Image.open\\(filepath\\)\n    cells = split_grid\\(img, 3, 3\\)\n    for i, faction in enumerate\\(grid_factions\\):\n        if faction in restored: continue\n        result = process_original\\(cells[i], cut_label=False\\)\n        if result:\n            result.save\\(os.path.join\\(outdir, f''banner_{faction}.png''\\), optimize=True\\)\n            restored[faction] = True\n            print\\(f''  {faction} <- {grid_file}[{i}] \\(3x3, original\\)''\\)\n\nprint\\(f''\\\\nRestored {len\\(restored\\)} good banners''\\)\n\n# Copy all to game dir\nfor faction in restored:\n    src = os.path.join\\(outdir, f''banner_{faction}.png''\\)\n    dst = os.path.join\\(gamedir, f''banner_{faction}.png''\\)\n    shutil.copy2\\(src, dst\\)\nprint\\(''Copied to game dir''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nimport os\n\noutdir = r''C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\n# Check current state of all 9 problem banners\nfor name in [''orcs_of_gundabad'', ''dominion_of_isengard'', ''havens_of_umbar'',\n             ''dwarves_of_orocarni'', ''clans_of_enedwaith'', ''forodwaith'', ''shadow_of_dol_guldur'',\n             ''dwarves_of_ered_luin'', ''fangorn_forest'']:\n    arr = np.array\\(Image.open\\(os.path.join\\(outdir, f''banner_{name}.png''\\)\\).convert\\(''RGBA''\\)\\)\n    # Top and bottom rows alpha\n    t0 = np.mean\\(arr[0,:,3]\\)\n    t1 = np.mean\\(arr[1,:,3]\\)\n    b126 = np.mean\\(arr[126,:,3]\\)\n    b127 = np.mean\\(arr[127,:,3]\\)\n    l0 = np.mean\\(arr[:,0,3]\\)\n    r83 = np.mean\\(arr[:,83,3]\\)\n    print\\(f''{name:<30} T0={t0:>5.0f} T1={t1:>5.0f} B126={b126:>5.0f} B127={b127:>5.0f} L0={l0:>5.0f} R83={r83:>5.0f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nimport os\n\n# Look at the source composite\nflags_dir = ''flags''\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nprint\\(f''Source: {img.size} mode={img.mode}''\\)\n\n# It''s a 2x2 grid \\(1024x1536, portrait = h > w\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\nprint\\(f''Cell size: {cell_w}x{cell_h}''\\)\n\n# Check what the 4 cells look like\nfactions = [''dwarves_of_orocarni'', ''clans_of_enedwaith'', ''forodwaith'', ''shadow_of_dol_guldur'']\nfor i in range\\(4\\):\n    r, c = divmod\\(i, 2\\)\n    x1 = c * cell_w\n    y1 = r * cell_h\n    cell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n    cell.save\\(f''_debug_cell_{i}_{factions[i]}.png''\\)\n    arr = np.array\\(cell.convert\\(''RGB''\\)\\)\n    brt = np.max\\(arr[:,:,:3], axis=2\\)\n    row_content = np.mean\\(brt > 25, axis=1\\)\n    # Find banner bottom \\(scan from 55% for gap\\)\n    banner_bottom = cell_h\n    for y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n        if row_content[y] < 0.08:\n            banner_bottom = y\n            break\n    print\\(f''{factions[i]}: cell {cell_w}x{cell_h}, banner_bottom={banner_bottom} \\({banner_bottom/cell_h*100:.0f}%\\)''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nimport os\n\noutdir = r''GUI\\\\SpriteData\\\\FactionMap''\n\n# Show the current output of the 4 new ones\nfor f in [''dwarves_of_orocarni'', ''clans_of_enedwaith'', ''forodwaith'', ''shadow_of_dol_guldur'']:\n    img = Image.open\\(os.path.join\\(outdir, f''banner_{f}.png''\\)\\).convert\\(''RGBA''\\)\n    arr = np.array\\(img\\)\n    # Check top rows: how much content is there?\n    for row in range\\(20\\):\n        alpha_mean = np.mean\\(arr[row, :, 3]\\)\n        content_frac = np.mean\\(arr[row, :, 3] > 10\\)\n        print\\(f''{f[:15]:>15} row {row:2d}: alpha_mean={alpha_mean:5.0f}  content={content_frac:.2f}''\\)\n    print\\(\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os, shutil\n\nflags_dir = ''flags''\noutdir = r''GUI\\\\SpriteData\\\\FactionMap''\ngamedir = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nCANVAS_W = 84\nCANVAS_H = 128\n\ndef make_black_transparent\\(img\\):\n    arr = np.array\\(img.convert\\(''RGBA''\\)\\)\n    brightness = np.max\\(arr[:, :, :3], axis=2\\)\n    dark = brightness < 25\n    seeds = np.zeros_like\\(dark\\)\n    seeds[0, :] = dark[0, :]\n    seeds[-1, :] = dark[-1, :]\n    seeds[:, 0] = dark[:, 0]\n    seeds[:, -1] = dark[:, -1]\n    labeled, _ = ndi.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    arr[bg_mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef keep_largest_component\\(img\\):\n    arr = np.array\\(img\\)\n    content_mask = arr[:, :, 3] > 10\n    labeled, num = ndi.label\\(content_mask\\)\n    if num == 0:\n        return img\n    sizes = ndi.sum\\(content_mask, labeled, range\\(1, num + 1\\)\\)\n    largest = np.argmax\\(sizes\\) + 1\n    mask = labeled == largest\n    arr[~mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef fill_transparent_edges\\(img\\):\n    arr = np.array\\(img\\)\n    h, w = arr.shape[:2]\n    for c in range\\(w\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    for c in range\\(w-1, -1, -1\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c+1, w\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    for r in range\\(h\\):\n        if np.mean\\(arr[r, :, 3]\\) > 30:\n            for fr in range\\(r\\): arr[fr, :, :] = arr[r, :, :]\n            break\n    for r in range\\(h-1, -1, -1\\):\n        if np.mean\\(arr[r, :, 3]\\) > 30:\n            for fr in range\\(r+1, h\\): arr[fr, :, :] = arr[r, :, :]\n            break\n    return Image.fromarray\\(arr\\)\n\ndef remove_rod\\(cell\\):\n    ''''''Remove the decorative rod/bar at the top of the banner.\n    The rod is a thin horizontal element. Below it is the actual banner fabric\n    which is much wider. Find where the fabric starts \\(row where content width \n    jumps significantly\\) and crop from there.''''''\n    arr = np.array\\(cell.convert\\(''RGB''\\)\\)\n    h, w = arr.shape[:2]\n    brightness = np.max\\(arr[:, :, :3], axis=2\\)\n    \n    # Per-row: how many pixels are non-black \\(content width\\)\n    row_width = np.sum\\(brightness > 30, axis=1\\)\n    \n    # The rod is narrow \\(~20-40% of cell width\\). The banner fabric is wide \\(>60%\\).\n    # Find first row from top where content is wide enough to be fabric\n    fabric_threshold = w * 0.55\n    \n    cut_y = 0\n    for y in range\\(h\\):\n        if row_width[y] > fabric_threshold:\n            # Go back a few pixels to include the very top of the fabric\n            cut_y = max\\(0, y - 2\\)\n            break\n    \n    if cut_y > 0:\n        print\\(f''    Rod removal: cutting top {cut_y} rows \\(rod was {cut_y/h*100:.0f}% of cell\\)''\\)\n    \n    return cell.crop\\(\\(0, cut_y, w, h\\)\\)\n\n# Process the 4 new ones\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\n\nfactions = [''dwarves_of_orocarni'', ''clans_of_enedwaith'', ''forodwaith'', ''shadow_of_dol_guldur'']\n\nfor i, faction in enumerate\\(factions\\):\n    r, c = divmod\\(i, 2\\)\n    x1 = c * cell_w\n    y1 = r * cell_h\n    cell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n    \n    print\\(f''{faction}:''\\)\n    \n    # Step 1: Find banner bottom \\(cut label text\\)\n    arr = np.array\\(cell.convert\\(''RGB''\\)\\)\n    brightness = np.max\\(arr[:, :, :3], axis=2\\)\n    row_content = np.mean\\(brightness > 25, axis=1\\)\n    banner_bottom = cell_h\n    for y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n        if row_content[y] < 0.08:\n            banner_bottom = y\n            break\n    cell = cell.crop\\(\\(0, 0, cell_w, banner_bottom\\)\\)\n    print\\(f''    Label cut: bottom at {banner_bottom}''\\)\n    \n    # Step 2: Remove rod/bar at top\n    cell = remove_rod\\(cell\\)\n    \n    # Step 3: Crop to content in RGB\n    arr_rgb = np.array\\(cell.convert\\(''RGB''\\)\\)\n    brt = np.max\\(arr_rgb[:, :, :3], axis=2\\)\n    content = brt > 20\n    rows = np.any\\(content, axis=1\\)\n    cols = np.any\\(content, axis=0\\)\n    if np.any\\(rows\\) and np.any\\(cols\\):\n        cy1 = int\\(np.argmax\\(rows\\)\\)\n        cy2 = int\\(arr_rgb.shape[0] - np.argmax\\(rows[::-1]\\)\\)\n        cx1 = int\\(np.argmax\\(cols\\)\\)\n        cx2 = int\\(arr_rgb.shape[1] - np.argmax\\(cols[::-1]\\)\\)\n        cell = cell.crop\\(\\(cx1, cy1, cx2, cy2\\)\\)\n    \n    print\\(f''    After crop: {cell.size}''\\)\n    \n    # Step 4: Resize to 84x128 WITH black bg\n    resized = cell.resize\\(\\(CANVAS_W, CANVAS_H\\), Image.LANCZOS\\)\n    \n    # Step 5: Make black transparent + largest component\n    result = make_black_transparent\\(resized\\)\n    result = keep_largest_component\\(result\\)\n    \n    # Step 6: Edge fill\n    result = fill_transparent_edges\\(result\\)\n    \n    arr_final = np.array\\(result\\)\n    fh, fw = arr_final.shape[:2]\n    L = np.mean\\(arr_final[:, 0, 3]\\)\n    R = np.mean\\(arr_final[:, fw-1, 3]\\)\n    T = np.mean\\(arr_final[0, :, 3]\\)\n    B = np.mean\\(arr_final[fh-1, :, 3]\\)\n    \n    outpath = os.path.join\\(outdir, f''banner_{faction}.png''\\)\n    result.save\\(outpath, optimize=True\\)\n    shutil.copy2\\(outpath, os.path.join\\(gamedir, f''banner_{faction}.png''\\)\\)\n    print\\(f''    Result: L={L:.0f} R={R:.0f} T={T:.0f} B={B:.0f}''\\)\n    print\\(\\)\n\nprint\\(''Done - saved and copied to game dir''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nimport os\n\nflags_dir = ''flags''\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\n\n# Dol Guldur is cell index 3 \\(bottom-right\\)\nr, c = divmod\\(3, 2\\)\nx1 = c * cell_w\ny1 = r * cell_h\ncell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n\n# Step 1: cut label\narr = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrightness = np.max\\(arr[:, :, :3], axis=2\\)\nrow_content = np.mean\\(brightness > 25, axis=1\\)\nbanner_bottom = cell_h\nfor y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n    if row_content[y] < 0.08:\n        banner_bottom = y\n        break\nprint\\(f''Banner bottom: {banner_bottom} / {cell_h}''\\)\n\n# Step 2: remove rod\ncell_cut = cell.crop\\(\\(0, 0, cell_w, banner_bottom\\)\\)\narr2 = np.array\\(cell_cut.convert\\(''RGB''\\)\\)\nh2, w2 = arr2.shape[:2]\nbrt2 = np.max\\(arr2[:, :, :3], axis=2\\)\nrow_width = np.sum\\(brt2 > 30, axis=1\\)\nfabric_threshold = w2 * 0.55\nrod_end = 0\nfor y in range\\(h2\\):\n    if row_width[y] > fabric_threshold:\n        rod_end = max\\(0, y - 2\\)\n        break\nprint\\(f''Rod end: {rod_end}''\\)\n\ncell_norod = cell_cut.crop\\(\\(0, rod_end, w2, h2\\)\\)\n\n# Step 3: crop to content\narr3 = np.array\\(cell_norod.convert\\(''RGB''\\)\\)\nbrt3 = np.max\\(arr3[:, :, :3], axis=2\\)\ncontent = brt3 > 20\nrows = np.any\\(content, axis=1\\)\ncols = np.any\\(content, axis=0\\)\ncy1 = int\\(np.argmax\\(rows\\)\\)\ncy2 = int\\(arr3.shape[0] - np.argmax\\(rows[::-1]\\)\\)\ncx1 = int\\(np.argmax\\(cols\\)\\)\ncx2 = int\\(arr3.shape[1] - np.argmax\\(cols[::-1]\\)\\)\ncropped = cell_norod.crop\\(\\(cx1, cy1, cx2, cy2\\)\\)\ncw, ch = cropped.size\nprint\\(f''Cropped content: {cw}x{ch}, aspect={ch/cw:.2f}''\\)\nprint\\(f''Target: 84x128, aspect={128/84:.2f}''\\)\nprint\\(f''Content is {\"\"wider\"\" if ch/cw < 128/84 else \"\"taller\"\"} than target''\\)\n\n# The issue: content aspect vs target aspect\n# If content is wider than target, it gets stretched vertically -> fringes elongated\n# Solution: fit to width, let height be natural, then pad or crop\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nimport os\n\noutdir = r''GUI\\\\SpriteData\\\\FactionMap''\nimg = Image.open\\(os.path.join\\(outdir, ''banner_shadow_of_dol_guldur.png''\\)\\).convert\\(''RGBA''\\)\narr = np.array\\(img\\)\nh, w = arr.shape[:2]\n\n# Check bottom rows - is edge fill stretching fringe down?\nfor row in range\\(h-1, h-25, -1\\):\n    alpha_mean = np.mean\\(arr[row, :, 3]\\)\n    content_frac = np.mean\\(arr[row, :, 3] > 10\\)\n    print\\(f''row {row}: alpha_mean={alpha_mean:5.0f}  content={content_frac:.2f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os, shutil\n\nflags_dir = ''flags''\noutdir = r''GUI\\\\SpriteData\\\\FactionMap''\ngamedir = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nCANVAS_W = 84\nCANVAS_H = 128\n\ndef make_black_transparent\\(img\\):\n    arr = np.array\\(img.convert\\(''RGBA''\\)\\)\n    brightness = np.max\\(arr[:, :, :3], axis=2\\)\n    dark = brightness < 25\n    seeds = np.zeros_like\\(dark\\)\n    seeds[0, :] = dark[0, :]\n    seeds[-1, :] = dark[-1, :]\n    seeds[:, 0] = dark[:, 0]\n    seeds[:, -1] = dark[:, -1]\n    labeled, _ = ndi.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    arr[bg_mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef keep_largest_component\\(img\\):\n    arr = np.array\\(img\\)\n    content_mask = arr[:, :, 3] > 10\n    labeled, num = ndi.label\\(content_mask\\)\n    if num == 0:\n        return img\n    sizes = ndi.sum\\(content_mask, labeled, range\\(1, num + 1\\)\\)\n    largest = np.argmax\\(sizes\\) + 1\n    mask = labeled == largest\n    arr[~mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef fill_transparent_edges_sides_and_top_only\\(img\\):\n    ''''''Only fill left, right and top transparent edges. Leave bottom natural.''''''\n    arr = np.array\\(img\\)\n    h, w = arr.shape[:2]\n    # Left\n    for c in range\\(w\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    # Right\n    for c in range\\(w-1, -1, -1\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c+1, w\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    # Top only\n    for r in range\\(h\\):\n        if np.mean\\(arr[r, :, 3]\\) > 30:\n            for fr in range\\(r\\): arr[fr, :, :] = arr[r, :, :]\n            break\n    # NO bottom fill - fringe is natural end\n    return Image.fromarray\\(arr\\)\n\n# Fix Dol Guldur\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\n\nfaction = ''shadow_of_dol_guldur''\nr, c = divmod\\(3, 2\\)\nx1 = c * cell_w\ny1 = r * cell_h\ncell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n\n# Cut label\narr = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrightness = np.max\\(arr[:, :, :3], axis=2\\)\nrow_content = np.mean\\(brightness > 25, axis=1\\)\nbanner_bottom = cell_h\nfor y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n    if row_content[y] < 0.08:\n        banner_bottom = y\n        break\ncell = cell.crop\\(\\(0, 0, cell_w, banner_bottom\\)\\)\n\n# Remove rod\narr2 = np.array\\(cell.convert\\(''RGB''\\)\\)\nh2, w2 = arr2.shape[:2]\nbrt2 = np.max\\(arr2[:, :, :3], axis=2\\)\nrow_width = np.sum\\(brt2 > 30, axis=1\\)\nfabric_threshold = w2 * 0.55\nrod_end = 0\nfor y in range\\(h2\\):\n    if row_width[y] > fabric_threshold:\n        rod_end = max\\(0, y - 2\\)\n        break\ncell = cell.crop\\(\\(0, rod_end, w2, h2\\)\\)\n\n# Crop to content in RGB\narr3 = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrt3 = np.max\\(arr3[:, :, :3], axis=2\\)\ncontent = brt3 > 20\nrows_mask = np.any\\(content, axis=1\\)\ncols_mask = np.any\\(content, axis=0\\)\ncy1 = int\\(np.argmax\\(rows_mask\\)\\)\ncy2 = int\\(arr3.shape[0] - np.argmax\\(rows_mask[::-1]\\)\\)\ncx1 = int\\(np.argmax\\(cols_mask\\)\\)\ncx2 = int\\(arr3.shape[1] - np.argmax\\(cols_mask[::-1]\\)\\)\ncell = cell.crop\\(\\(cx1, cy1, cx2, cy2\\)\\)\ncw, ch = cell.size\nprint\\(f''Content: {cw}x{ch}, aspect={ch/cw:.2f}''\\)\n\n# Proportional fit: scale to fill width, natural height\nscale = CANVAS_W / cw\nnew_h = int\\(ch * scale\\)\nprint\\(f''Scaled: {CANVAS_W}x{new_h}''\\)\n\nif new_h > CANVAS_H:\n    # Would exceed canvas - just stretch \\(shouldn''t happen here\\)\n    resized = cell.resize\\(\\(CANVAS_W, CANVAS_H\\), Image.LANCZOS\\)\nelse:\n    # Proportional: place at top of transparent canvas\n    resized = cell.resize\\(\\(CANVAS_W, new_h\\), Image.LANCZOS\\)\n    canvas = Image.new\\(''RGBA'', \\(CANVAS_W, CANVAS_H\\), \\(0, 0, 0, 0\\)\\)\n    canvas.paste\\(resized, \\(0, 0\\)\\)\n    resized = canvas\n\n# Make black transparent + largest component\nresult = make_black_transparent\\(resized\\)\nresult = keep_largest_component\\(result\\)\n\n# Edge fill: sides + top only, NOT bottom \\(preserve fringe\\)\nresult = fill_transparent_edges_sides_and_top_only\\(result\\)\n\noutpath = os.path.join\\(outdir, f''banner_{faction}.png''\\)\nresult.save\\(outpath, optimize=True\\)\nshutil.copy2\\(outpath, os.path.join\\(gamedir, f''banner_{faction}.png''\\)\\)\n\narr_final = np.array\\(result\\)\nfh, fw = arr_final.shape[:2]\nL = np.mean\\(arr_final[:, 0, 3]\\)\nR = np.mean\\(arr_final[:, fw-1, 3]\\)\nT = np.mean\\(arr_final[0, :, 3]\\)\nB = np.mean\\(arr_final[fh-1, :, 3]\\)\n# Find where actual content ends at bottom\nfor row in range\\(fh-1, -1, -1\\):\n    if np.mean\\(arr_final[row, :, 3]\\) > 20:\n        print\\(f''Content ends at row {row}/{fh}''\\)\n        break\nprint\\(f''Result: L={L:.0f} R={R:.0f} T={T:.0f} B={B:.0f}''\\)\nprint\\(''Saved and copied''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nimport os\n\nflags_dir = ''flags''\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\n\n# Compare Forodwaith \\(cell 2\\) vs Dol Guldur \\(cell 3\\)\nfor idx, name in [\\(2, ''forodwaith''\\), \\(3, ''dol_guldur''\\)]:\n    r, c = divmod\\(idx, 2\\)\n    x1 = c * cell_w\n    y1 = r * cell_h\n    cell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n    arr = np.array\\(cell.convert\\(''RGB''\\)\\)\n    brt = np.max\\(arr[:,:,:3], axis=2\\)\n    row_width = np.sum\\(brt > 30, axis=1\\)\n    row_content = np.mean\\(brt > 25, axis=1\\)\n    \n    print\\(f''=== {name} ===''\\)\n    # Show top 20 rows\n    for y in range\\(25\\):\n        print\\(f''  row {y:3d}: width={row_width[y]:4d}/{cell_w}  content={row_content[y]:.2f}''\\)\n    print\\(''  ...''\\)\n    # Show bottom\n    banner_bottom = cell_h\n    for y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n        if row_content[y] < 0.08:\n            banner_bottom = y\n            break\n    print\\(f''  banner_bottom={banner_bottom}''\\)\n    # Fabric threshold\n    fabric_threshold = cell_w * 0.55\n    rod_end = 0\n    for y in range\\(cell_h\\):\n        if row_width[y] > fabric_threshold:\n            rod_end = max\\(0, y - 2\\)\n            break\n    print\\(f''  rod_end={rod_end} \\(fabric_threshold={fabric_threshold:.0f}\\)''\\)\n    print\\(\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os\n\nflags_dir = ''flags''\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\n\n# Dol Guldur cell\nr, c = divmod\\(3, 2\\)\nx1 = c * cell_w\ny1 = r * cell_h\ncell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n\n# Cut label\narr = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrightness = np.max\\(arr[:, :, :3], axis=2\\)\nrow_content = np.mean\\(brightness > 25, axis=1\\)\nbanner_bottom = cell_h\nfor y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n    if row_content[y] < 0.08:\n        banner_bottom = y\n        break\n\n# Remove rod\ncell_cut = cell.crop\\(\\(0, 0, cell_w, banner_bottom\\)\\)\narr2 = np.array\\(cell_cut.convert\\(''RGB''\\)\\)\nh2, w2 = arr2.shape[:2]\nbrt2 = np.max\\(arr2[:, :, :3], axis=2\\)\nrow_width = np.sum\\(brt2 > 30, axis=1\\)\nfabric_threshold = w2 * 0.55\nrod_end = 0\nfor y in range\\(h2\\):\n    if row_width[y] > fabric_threshold:\n        rod_end = max\\(0, y - 2\\)\n        break\n\ncell_norod = cell_cut.crop\\(\\(0, rod_end, w2, h2\\)\\)\n\n# Crop to content\narr3 = np.array\\(cell_norod.convert\\(''RGB''\\)\\)\nbrt3 = np.max\\(arr3[:, :, :3], axis=2\\)\ncontent = brt3 > 20\nrows_mask = np.any\\(content, axis=1\\)\ncols_mask = np.any\\(content, axis=0\\)\ncy1 = int\\(np.argmax\\(rows_mask\\)\\)\ncy2 = int\\(arr3.shape[0] - np.argmax\\(rows_mask[::-1]\\)\\)\ncx1 = int\\(np.argmax\\(cols_mask\\)\\)\ncx2 = int\\(arr3.shape[1] - np.argmax\\(cols_mask[::-1]\\)\\)\ncropped = cell_norod.crop\\(\\(cx1, cy1, cx2, cy2\\)\\)\n\nprint\\(f''Cropped content: {cropped.size}''\\)\n\n# Show bottom rows of the cropped content - where are the fringes?\narr_c = np.array\\(cropped.convert\\(''RGB''\\)\\)\nch, cw = arr_c.shape[:2]\nbrt_c = np.max\\(arr_c[:, :, :3], axis=2\\)\nprint\\(f''\\\\nBottom rows of cropped content \\(before any resize\\):''\\)\nfor y in range\\(ch-30, ch\\):\n    rw = np.sum\\(brt_c[y, :] > 20\\)\n    rc = np.mean\\(brt_c[y, :] > 20\\)\n    print\\(f''  row {y}/{ch}: width={rw:4d}/{cw}  content={rc:.2f}''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os, shutil\n\nflags_dir = ''flags''\noutdir = r''GUI\\\\SpriteData\\\\FactionMap''\ngamedir = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nCANVAS_W = 84\nCANVAS_H = 128\n\ndef make_black_transparent\\(img\\):\n    arr = np.array\\(img.convert\\(''RGBA''\\)\\)\n    brightness = np.max\\(arr[:, :, :3], axis=2\\)\n    dark = brightness < 25\n    seeds = np.zeros_like\\(dark\\)\n    seeds[0, :] = dark[0, :]\n    seeds[-1, :] = dark[-1, :]\n    seeds[:, 0] = dark[:, 0]\n    seeds[:, -1] = dark[:, -1]\n    labeled, _ = ndi.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    arr[bg_mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef keep_largest_component\\(img\\):\n    arr = np.array\\(img\\)\n    content_mask = arr[:, :, 3] > 10\n    labeled, num = ndi.label\\(content_mask\\)\n    if num == 0:\n        return img\n    sizes = ndi.sum\\(content_mask, labeled, range\\(1, num + 1\\)\\)\n    largest = np.argmax\\(sizes\\) + 1\n    mask = labeled == largest\n    arr[~mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef fill_edges_no_bottom\\(img\\):\n    ''''''Fill transparent edges on left, right, top only. Leave bottom natural for fringes.''''''\n    arr = np.array\\(img\\)\n    h, w = arr.shape[:2]\n    for c in range\\(w\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    for c in range\\(w-1, -1, -1\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c+1, w\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    for r in range\\(h\\):\n        if np.mean\\(arr[r, :, 3]\\) > 30:\n            for fr in range\\(r\\): arr[fr, :, :] = arr[r, :, :]\n            break\n    # NO bottom fill\n    return Image.fromarray\\(arr\\)\n\n# Only fix Dol Guldur\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\n\nfaction = ''shadow_of_dol_guldur''\nr, c = divmod\\(3, 2\\)\nx1 = c * cell_w\ny1 = r * cell_h\ncell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n\n# Cut label\narr = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrightness = np.max\\(arr[:, :, :3], axis=2\\)\nrow_content = np.mean\\(brightness > 25, axis=1\\)\nbanner_bottom = cell_h\nfor y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n    if row_content[y] < 0.08:\n        banner_bottom = y\n        break\ncell = cell.crop\\(\\(0, 0, cell_w, banner_bottom\\)\\)\n\n# Remove rod\narr2 = np.array\\(cell.convert\\(''RGB''\\)\\)\nh2, w2 = arr2.shape[:2]\nbrt2 = np.max\\(arr2[:, :, :3], axis=2\\)\nrow_width = np.sum\\(brt2 > 30, axis=1\\)\nfabric_threshold = w2 * 0.55\nrod_end = 0\nfor y in range\\(h2\\):\n    if row_width[y] > fabric_threshold:\n        rod_end = max\\(0, y - 2\\)\n        break\ncell = cell.crop\\(\\(0, rod_end, w2, h2\\)\\)\n\n# Crop to content\narr3 = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrt3 = np.max\\(arr3[:, :, :3], axis=2\\)\ncontent = brt3 > 20\nrows_mask = np.any\\(content, axis=1\\)\ncols_mask = np.any\\(content, axis=0\\)\ncy1 = int\\(np.argmax\\(rows_mask\\)\\)\ncy2 = int\\(arr3.shape[0] - np.argmax\\(rows_mask[::-1]\\)\\)\ncx1 = int\\(np.argmax\\(cols_mask\\)\\)\ncx2 = int\\(arr3.shape[1] - np.argmax\\(cols_mask[::-1]\\)\\)\ncell = cell.crop\\(\\(cx1, cy1, cx2, cy2\\)\\)\n\n# v3: resize to 84x128 with black bg, then transparent\nresized = cell.resize\\(\\(CANVAS_W, CANVAS_H\\), Image.LANCZOS\\)\nresult = make_black_transparent\\(resized\\)\nresult = keep_largest_component\\(result\\)\n\n# Edge fill: sides + top only, NOT bottom \\(preserve fringes\\)\nresult = fill_edges_no_bottom\\(result\\)\n\noutpath = os.path.join\\(outdir, f''banner_{faction}.png''\\)\nresult.save\\(outpath, optimize=True\\)\nshutil.copy2\\(outpath, os.path.join\\(gamedir, f''banner_{faction}.png''\\)\\)\nprint\\(''Saved and copied''\\)\n\")",
      "Bash(\"C:\\\\Program Files\\\\AILocal\\\\python\\\\3.10\\\\python.exe\" -c \"\nfrom PIL import Image\nimport numpy as np\nfrom scipy import ndimage as ndi\nimport os, shutil\n\nflags_dir = ''flags''\noutdir = r''GUI\\\\SpriteData\\\\FactionMap''\ngamedir = r''D:\\\\Steam\\\\steamapps\\\\common\\\\Mount & Blade II Bannerlord\\\\Modules\\\\LOTRAOM.FactionMap\\\\GUI\\\\SpriteData\\\\FactionMap''\n\nCANVAS_W = 84\nCANVAS_H = 128\n\ndef make_black_transparent_gentle\\(img, dark_threshold=15\\):\n    ''''''Flood-fill black from edges -> transparent. Lower threshold preserves dark fringes.''''''\n    arr = np.array\\(img.convert\\(''RGBA''\\)\\)\n    brightness = np.max\\(arr[:, :, :3], axis=2\\)\n    dark = brightness < dark_threshold\n    seeds = np.zeros_like\\(dark\\)\n    seeds[0, :] = dark[0, :]\n    seeds[-1, :] = dark[-1, :]\n    seeds[:, 0] = dark[:, 0]\n    seeds[:, -1] = dark[:, -1]\n    labeled, _ = ndi.label\\(dark\\)\n    seed_labels = set\\(labeled[seeds].flatten\\(\\)\\) - {0}\n    bg_mask = np.zeros_like\\(dark\\)\n    for lbl in seed_labels:\n        bg_mask |= \\(labeled == lbl\\)\n    arr[bg_mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef keep_largest_component\\(img\\):\n    arr = np.array\\(img\\)\n    content_mask = arr[:, :, 3] > 10\n    labeled, num = ndi.label\\(content_mask\\)\n    if num == 0:\n        return img\n    sizes = ndi.sum\\(content_mask, labeled, range\\(1, num + 1\\)\\)\n    largest = np.argmax\\(sizes\\) + 1\n    mask = labeled == largest\n    arr[~mask, 3] = 0\n    return Image.fromarray\\(arr\\)\n\ndef fill_edges_no_bottom\\(img\\):\n    arr = np.array\\(img\\)\n    h, w = arr.shape[:2]\n    for c in range\\(w\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    for c in range\\(w-1, -1, -1\\):\n        if np.mean\\(arr[:, c, 3]\\) > 30:\n            for fc in range\\(c+1, w\\): arr[:, fc, :] = arr[:, c, :]\n            break\n    for r in range\\(h\\):\n        if np.mean\\(arr[r, :, 3]\\) > 30:\n            for fr in range\\(r\\): arr[fr, :, :] = arr[r, :, :]\n            break\n    return Image.fromarray\\(arr\\)\n\n# Fix Dol Guldur with lower dark threshold to preserve fringes\nfname = ''ChatGPT Image 11. Feb. 2026, 11_48_30.png''\nimg = Image.open\\(os.path.join\\(flags_dir, fname\\)\\)\nw, h = img.size\ncell_w = w // 2\ncell_h = h // 2\n\nfaction = ''shadow_of_dol_guldur''\nr, c = divmod\\(3, 2\\)\nx1 = c * cell_w\ny1 = r * cell_h\ncell = img.crop\\(\\(x1, y1, x1 + cell_w, y1 + cell_h\\)\\)\n\n# Cut label\narr = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrightness = np.max\\(arr[:, :, :3], axis=2\\)\nrow_content = np.mean\\(brightness > 25, axis=1\\)\nbanner_bottom = cell_h\nfor y in range\\(int\\(cell_h * 0.55\\), cell_h\\):\n    if row_content[y] < 0.08:\n        banner_bottom = y\n        break\ncell = cell.crop\\(\\(0, 0, cell_w, banner_bottom\\)\\)\n\n# Remove rod\narr2 = np.array\\(cell.convert\\(''RGB''\\)\\)\nh2, w2 = arr2.shape[:2]\nbrt2 = np.max\\(arr2[:, :, :3], axis=2\\)\nrow_width = np.sum\\(brt2 > 30, axis=1\\)\nfabric_threshold = w2 * 0.55\nrod_end = 0\nfor y in range\\(h2\\):\n    if row_width[y] > fabric_threshold:\n        rod_end = max\\(0, y - 2\\)\n        break\ncell = cell.crop\\(\\(0, rod_end, w2, h2\\)\\)\n\n# Crop to content\narr3 = np.array\\(cell.convert\\(''RGB''\\)\\)\nbrt3 = np.max\\(arr3[:, :, :3], axis=2\\)\ncontent = brt3 > 20\nrows_mask = np.any\\(content, axis=1\\)\ncols_mask = np.any\\(content, axis=0\\)\ncy1 = int\\(np.argmax\\(rows_mask\\)\\)\ncy2 = int\\(arr3.shape[0] - np.argmax\\(rows_mask[::-1]\\)\\)\ncx1 = int\\(np.argmax\\(cols_mask\\)\\)\ncx2 = int\\(arr3.shape[1] - np.argmax\\(cols_mask[::-1]\\)\\)\ncell = cell.crop\\(\\(cx1, cy1, cx2, cy2\\)\\)\n\n# Resize with black bg\nresized = cell.resize\\(\\(CANVAS_W, CANVAS_H\\), Image.LANCZOS\\)\n\n# Gentle transparency: threshold=12 instead of 25 to preserve dark fringes\nresult = make_black_transparent_gentle\\(resized, dark_threshold=12\\)\nresult = keep_largest_component\\(result\\)\nresult = fill_edges_no_bottom\\(result\\)\n\noutpath = os.path.join\\(outdir, f''banner_{faction}.png''\\)\nresult.save\\(outpath, optimize=True\\)\nshutil.copy2\\(outpath, os.path.join\\(gamedir, f''banner_{faction}.png''\\)\\)\n\narr_final = np.array\\(result\\)\n# Check bottom fringe area\nprint\\(''Bottom rows alpha:''\\)\nfor y in range\\(108, 128\\):\n    alpha_mean = np.mean\\(arr_final[y, :, 3]\\)\n    content_frac = np.mean\\(arr_final[y, :, 3] > 10\\)\n    print\\(f''  row {y}: alpha={alpha_mean:5.0f}  content={content_frac:.2f}''\\)\nprint\\(''Saved and copied''\\)\n\")",
      "Bash(del \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_debug_cell_0_dwarves_of_orocarni.png\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_debug_cell_1_clans_of_enedwaith.png\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_debug_cell_2_forodwaith.png\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_debug_cell_3_shadow_of_dol_guldur.png\" \"C:\\\\Work\\\\Sources\\\\github\\\\LOTRAOM_FactionMap\\\\_cell_debug_script.py\")"
    ]
  }
}
